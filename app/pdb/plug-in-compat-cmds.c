/* PICMAN - The GNU Image Manipulation Program
 * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl. */

#include "config.h"

#include <cairo.h>

#include <gegl.h>

#include <gdk-pixbuf/gdk-pixbuf.h>

#include "libpicmanbase/picmanbase.h"
#include "libpicmancolor/picmancolor.h"

#include "libpicmanbase/picmanbase.h"

#include "pdb-types.h"

#include "core/picmancontext.h"
#include "core/picmandrawable-operation.h"
#include "core/picmandrawable.h"
#include "core/picmanimage-crop.h"
#include "core/picmanimage-undo.h"
#include "core/picmanimage.h"
#include "core/picmanparamspecs.h"
#include "core/picmanpickable-auto-shrink.h"
#include "core/picmanpickable.h"
#include "gegl/picman-gegl-utils.h"

#include "picmanpdb.h"
#include "picmanpdb-utils.h"
#include "picmanprocedure.h"
#include "internal-procs.h"

#include "picman-intl.h"


static PicmanValueArray *
plug_in_autocrop_invoker (PicmanProcedure         *procedure,
                          Picman                  *picman,
                          PicmanContext           *context,
                          PicmanProgress          *progress,
                          const PicmanValueArray  *args,
                          GError               **error)
{
  gboolean success = TRUE;
  PicmanImage *image;
  PicmanDrawable *drawable;

  image = picman_value_get_image (picman_value_array_index (args, 1), picman);
  drawable = picman_value_get_drawable (picman_value_array_index (args, 2), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error))
        {
          gint x1, y1, x2, y2;

          if (picman_pickable_auto_shrink (PICMAN_PICKABLE (drawable),
                                         0, 0,
                                         picman_item_get_width  (PICMAN_ITEM (drawable)),
                                         picman_item_get_height (PICMAN_ITEM (drawable)),
                                         &x1, &y1, &x2, &y2))
            {
              gint off_x, off_y;

              picman_item_get_offset (PICMAN_ITEM (drawable), &off_x, &off_y);

              x1 += off_x; x2 += off_x;
              y1 += off_y; y2 += off_y;

              picman_image_undo_group_start (image, PICMAN_UNDO_GROUP_ITEM_RESIZE,
                                           _("Autocrop image"));

              picman_image_crop (image, context,
                               x2 - x1, y2 - y1, -x1, -y1, TRUE);

              picman_image_undo_group_end (image);
            }
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plug_in_autocrop_layer_invoker (PicmanProcedure         *procedure,
                                Picman                  *picman,
                                PicmanContext           *context,
                                PicmanProgress          *progress,
                                const PicmanValueArray  *args,
                                GError               **error)
{
  gboolean success = TRUE;
  PicmanImage *image;
  PicmanDrawable *drawable;

  image = picman_value_get_image (picman_value_array_index (args, 1), picman);
  drawable = picman_value_get_drawable (picman_value_array_index (args, 2), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error))
        {
          PicmanLayer *layer = picman_image_get_active_layer (image);
          gint       x1, y1, x2, y2;

          if (layer &&
              picman_pickable_auto_shrink (PICMAN_PICKABLE (drawable),
                                         0, 0,
                                         picman_item_get_width  (PICMAN_ITEM (drawable)),
                                         picman_item_get_height (PICMAN_ITEM (drawable)),
                                         &x1, &y1, &x2, &y2))
            {
              picman_image_undo_group_start (image, PICMAN_UNDO_GROUP_ITEM_RESIZE,
                                           _("Autocrop layer"));

              picman_item_resize (PICMAN_ITEM (layer), context,
                                x2 - x1, y2 - y1, -x1, -y1);

              picman_image_undo_group_end (image);
            }
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plug_in_colortoalpha_invoker (PicmanProcedure         *procedure,
                              Picman                  *picman,
                              PicmanContext           *context,
                              PicmanProgress          *progress,
                              const PicmanValueArray  *args,
                              GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  PicmanRGB color;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 2), picman);
  picman_value_get_rgb (picman_value_array_index (args, 3), &color);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          /* XXX: fixme disable for gray, and add alpha when needed */

          GeglColor *gegl_color = picman_gegl_color_new (&color);
          GeglNode  *node =
            gegl_node_new_child (NULL,
                                 "operation", "gegl:color-to-alpha",
                                 "color",     gegl_color,
                                 NULL);
          g_object_unref (gegl_color);

          picman_drawable_apply_operation (drawable, progress,
                                         C_("undo-type", "Color to Alpha"),
                                         node);

          g_object_unref (node);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plug_in_pixelize_invoker (PicmanProcedure         *procedure,
                          Picman                  *picman,
                          PicmanContext           *context,
                          PicmanProgress          *progress,
                          const PicmanValueArray  *args,
                          GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 pixel_width;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 2), picman);
  pixel_width = g_value_get_int (picman_value_array_index (args, 3));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          GeglNode *node =
            gegl_node_new_child (NULL,
                                 "operation", "gegl:pixelise",
                                 "size-x",    pixel_width,
                                 "size-y",    pixel_width,
                                 NULL);

          picman_drawable_apply_operation (drawable, progress,
                                         C_("undo-type", "Pixelize"),
                                         node);

          g_object_unref (node);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plug_in_pixelize2_invoker (PicmanProcedure         *procedure,
                           Picman                  *picman,
                           PicmanContext           *context,
                           PicmanProgress          *progress,
                           const PicmanValueArray  *args,
                           GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 pixel_width;
  gint32 pixel_height;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 2), picman);
  pixel_width = g_value_get_int (picman_value_array_index (args, 3));
  pixel_height = g_value_get_int (picman_value_array_index (args, 4));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          GeglNode *node =
            gegl_node_new_child (NULL,
                                 "operation", "gegl:pixelise",
                                 "size-x",    pixel_width,
                                 "size-y",    pixel_height,
                                 NULL);

          picman_drawable_apply_operation (drawable, progress,
                                         C_("undo-type", "Pixelize"),
                                         node);

          g_object_unref (node);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plug_in_polar_coords_invoker (PicmanProcedure         *procedure,
                              Picman                  *picman,
                              PicmanContext           *context,
                              PicmanProgress          *progress,
                              const PicmanValueArray  *args,
                              GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gdouble circle;
  gdouble angle;
  gboolean backwards;
  gboolean inverse;
  gboolean polrec;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 2), picman);
  circle = g_value_get_double (picman_value_array_index (args, 3));
  angle = g_value_get_double (picman_value_array_index (args, 4));
  backwards = g_value_get_boolean (picman_value_array_index (args, 5));
  inverse = g_value_get_boolean (picman_value_array_index (args, 6));
  polrec = g_value_get_boolean (picman_value_array_index (args, 7));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          GeglNode *node =
            gegl_node_new_child (NULL,
                                 "operation", "gegl:polar-coords",
                                 "depth",     circle,
                                 "angle",     angle,
                                 "bw",        backwards, /* XXX name */
                                 "top",       inverse,
                                 "polar",     polrec,
                                 NULL);

          picman_drawable_apply_operation (drawable, progress,
                                         C_("undo-type", "Polar Coordinates"),
                                         node);

          g_object_unref (node);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plug_in_randomize_hurl_invoker (PicmanProcedure         *procedure,
                                Picman                  *picman,
                                PicmanContext           *context,
                                PicmanProgress          *progress,
                                const PicmanValueArray  *args,
                                GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gdouble rndm_pct;
  gdouble rndm_rcount;
  gboolean randomize;
  gint32 seed;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 2), picman);
  rndm_pct = g_value_get_double (picman_value_array_index (args, 3));
  rndm_rcount = g_value_get_double (picman_value_array_index (args, 4));
  randomize = g_value_get_boolean (picman_value_array_index (args, 5));
  seed = g_value_get_int (picman_value_array_index (args, 6));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          GeglNode *node;

          if (randomize)
            seed = g_random_int ();

          node =
            gegl_node_new_child (NULL,
                                 "operation",  "gegl:noise-hurl",
                                 "seed",       seed,
                                 "pct-random", rndm_pct,
                                 "repeat",     (gint) rndm_rcount,
                                 NULL);

          picman_drawable_apply_operation (drawable, progress,
                                         C_("undo-type", "Random Hurl"),
                                         node);

          g_object_unref (node);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plug_in_randomize_pick_invoker (PicmanProcedure         *procedure,
                                Picman                  *picman,
                                PicmanContext           *context,
                                PicmanProgress          *progress,
                                const PicmanValueArray  *args,
                                GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gdouble rndm_pct;
  gdouble rndm_rcount;
  gboolean randomize;
  gint32 seed;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 2), picman);
  rndm_pct = g_value_get_double (picman_value_array_index (args, 3));
  rndm_rcount = g_value_get_double (picman_value_array_index (args, 4));
  randomize = g_value_get_boolean (picman_value_array_index (args, 5));
  seed = g_value_get_int (picman_value_array_index (args, 6));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          GeglNode *node;

          if (randomize)
            seed = g_random_int ();

          node =
            gegl_node_new_child (NULL,
                                 "operation",  "gegl:noise-pick",
                                 "seed",       seed,
                                 "pct-random", rndm_pct,
                                 "repeat",     (gint) rndm_rcount,
                                 NULL);

          picman_drawable_apply_operation (drawable, progress,
                                         C_("undo-type", "Random Pick"),
                                         node);

          g_object_unref (node);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plug_in_randomize_slur_invoker (PicmanProcedure         *procedure,
                                Picman                  *picman,
                                PicmanContext           *context,
                                PicmanProgress          *progress,
                                const PicmanValueArray  *args,
                                GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gdouble rndm_pct;
  gdouble rndm_rcount;
  gboolean randomize;
  gint32 seed;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 2), picman);
  rndm_pct = g_value_get_double (picman_value_array_index (args, 3));
  rndm_rcount = g_value_get_double (picman_value_array_index (args, 4));
  randomize = g_value_get_boolean (picman_value_array_index (args, 5));
  seed = g_value_get_int (picman_value_array_index (args, 6));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          GeglNode *node;

          if (randomize)
            seed = g_random_int ();

          node =
            gegl_node_new_child (NULL,
                                 "operation",  "gegl:noise-slur",
                                 "seed",       seed,
                                 "pct-random", rndm_pct,
                                 "repeat",     (gint) rndm_rcount,
                                 NULL);

          picman_drawable_apply_operation (drawable, progress,
                                         C_("undo-type", "Random Slur"),
                                         node);

          g_object_unref (node);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plug_in_semiflatten_invoker (PicmanProcedure         *procedure,
                             Picman                  *picman,
                             PicmanContext           *context,
                             PicmanProgress          *progress,
                             const PicmanValueArray  *args,
                             GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 2), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error) &&
          picman_drawable_has_alpha (drawable))
        {
          GeglNode *node;
          PicmanRGB   color;

          picman_context_get_background (context, &color);

          node =
            gegl_node_new_child (NULL,
                                 "operation", "picman:semi-flatten",
                                 "color",     &color,
                                 NULL);

          picman_drawable_apply_operation (drawable, progress,
                                         C_("undo-type", "Semi-Flatten"),
                                         node);

          g_object_unref (node);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plug_in_threshold_alpha_invoker (PicmanProcedure         *procedure,
                                 Picman                  *picman,
                                 PicmanContext           *context,
                                 PicmanProgress          *progress,
                                 const PicmanValueArray  *args,
                                 GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 threshold;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 2), picman);
  threshold = g_value_get_int (picman_value_array_index (args, 3));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error) &&
          picman_drawable_has_alpha (drawable))
        {
          GeglNode *node =
            gegl_node_new_child (NULL,
                                 "operation", "picman:threshold-alpha",
                                 "value",     threshold / 255.0,
                                 NULL);

          picman_drawable_apply_operation (drawable, progress,
                                         C_("undo-type", "Threshold Alpha"),
                                         node);

          g_object_unref (node);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plug_in_vinvert_invoker (PicmanProcedure         *procedure,
                         Picman                  *picman,
                         PicmanContext           *context,
                         PicmanProgress          *progress,
                         const PicmanValueArray  *args,
                         GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 2), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          GeglNode *node =
            gegl_node_new_child (NULL,
                                 "operation", "gegl:value-invert",
                                 NULL);

          picman_drawable_apply_operation (drawable, progress,
                                         C_("undo-type", "Value Invert"),
                                         node);

          g_object_unref (node);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

void
register_plug_in_compat_procs (PicmanPDB *pdb)
{
  PicmanProcedure *procedure;

  /*
   * picman-plug-in-autocrop
   */
  procedure = picman_procedure_new (plug_in_autocrop_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "plug-in-autocrop");
  picman_procedure_set_static_strings (procedure,
                                     "plug-in-autocrop",
                                     "Remove empty borders from the image",
                                     "Remove empty borders from the image.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("run-mode",
                                                  "run mode",
                                                  "The run mode",
                                                  PICMAN_TYPE_RUN_MODE,
                                                  PICMAN_RUN_INTERACTIVE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "Input image)",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "Input drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plug-in-autocrop-layer
   */
  procedure = picman_procedure_new (plug_in_autocrop_layer_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "plug-in-autocrop-layer");
  picman_procedure_set_static_strings (procedure,
                                     "plug-in-autocrop-layer",
                                     "Remove empty borders from the layer",
                                     "Remove empty borders from the layer.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("run-mode",
                                                  "run mode",
                                                  "The run mode",
                                                  PICMAN_TYPE_RUN_MODE,
                                                  PICMAN_RUN_INTERACTIVE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "Input image)",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "Input drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plug-in-colortoalpha
   */
  procedure = picman_procedure_new (plug_in_colortoalpha_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "plug-in-colortoalpha");
  picman_procedure_set_static_strings (procedure,
                                     "plug-in-colortoalpha",
                                     "Convert a specified color to transparency",
                                     "This replaces as much of a given color as possible in each pixel with a corresponding amount of alpha, then readjusts the color accordingly.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1999",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("run-mode",
                                                  "run mode",
                                                  "The run mode",
                                                  PICMAN_TYPE_RUN_MODE,
                                                  PICMAN_RUN_INTERACTIVE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "Input image (unused)",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "Input drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_rgb ("color",
                                                    "color",
                                                    "Color to remove",
                                                    FALSE,
                                                    NULL,
                                                    PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plug-in-pixelize
   */
  procedure = picman_procedure_new (plug_in_pixelize_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "plug-in-pixelize");
  picman_procedure_set_static_strings (procedure,
                                     "plug-in-pixelize",
                                     "Simplify image into an array of solid-colored squares",
                                     "Pixelize the contents of the specified drawable with specified pixelizing width.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("run-mode",
                                                  "run mode",
                                                  "The run mode",
                                                  PICMAN_TYPE_RUN_MODE,
                                                  PICMAN_RUN_INTERACTIVE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "Input image (unused)",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "Input drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("pixel-width",
                                                      "pixel width",
                                                      "Pixel width (the decrease in resolution)",
                                                      1, PICMAN_MAX_IMAGE_SIZE, 1,
                                                      PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plug-in-pixelize2
   */
  procedure = picman_procedure_new (plug_in_pixelize2_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "plug-in-pixelize2");
  picman_procedure_set_static_strings (procedure,
                                     "plug-in-pixelize2",
                                     "Simplify image into an array of solid-colored rectangles",
                                     "Pixelize the contents of the specified drawable with specified pixelizing width and height.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("run-mode",
                                                  "run mode",
                                                  "The run mode",
                                                  PICMAN_TYPE_RUN_MODE,
                                                  PICMAN_RUN_INTERACTIVE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "Input image (unused)",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "Input drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("pixel-width",
                                                      "pixel width",
                                                      "Pixel width (the decrease in horizontal resolution)",
                                                      1, PICMAN_MAX_IMAGE_SIZE, 1,
                                                      PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("pixel-height",
                                                      "pixel height",
                                                      "Pixel height (the decrease in vertical resolution)",
                                                      1, PICMAN_MAX_IMAGE_SIZE, 1,
                                                      PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plug-in-polar-coords
   */
  procedure = picman_procedure_new (plug_in_polar_coords_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "plug-in-polar-coords");
  picman_procedure_set_static_strings (procedure,
                                     "plug-in-polar-coords",
                                     "Convert image to or from polar coordinates",
                                     "Remaps and image from rectangular coordinates to polar coordinates or vice versa.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("run-mode",
                                                  "run mode",
                                                  "The run mode",
                                                  PICMAN_TYPE_RUN_MODE,
                                                  PICMAN_RUN_INTERACTIVE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "Input image (unused)",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "Input drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("circle",
                                                    "circle",
                                                    "Circle depth in %",
                                                    0.0, 100.0, 0.0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("angle",
                                                    "angle",
                                                    "Offset angle",
                                                    0.0, 360.0, 0.0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("backwards",
                                                     "backwards",
                                                     "Map backwards",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("inverse",
                                                     "inverse",
                                                     "Map from top",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("polrec",
                                                     "polrec",
                                                     "Polar to rectangular",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plug-in-randomize-hurl
   */
  procedure = picman_procedure_new (plug_in_randomize_hurl_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "plug-in-randomize-hurl");
  picman_procedure_set_static_strings (procedure,
                                     "plug-in-randomize-hurl",
                                     "Completely randomize a fraction of pixels",
                                     "This plug-in \"hurls\" randomly-valued pixels onto the selection or image. You may select the percentage of pixels to modify and the number of times to repeat the process.",
                                     "Compatibility procedure. Please see 'gegl:noise-hurl' for credits.",
                                     "Compatibility procedure. Please see 'gegl:noise-hurl' for credits.",
                                     "2013",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("run-mode",
                                                  "run mode",
                                                  "The run mode",
                                                  PICMAN_TYPE_RUN_MODE,
                                                  PICMAN_RUN_INTERACTIVE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "Input image (unused)",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "Input drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("rndm-pct",
                                                    "rndm pct",
                                                    "Randomization percentage",
                                                    1.0, 100.0, 1.0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("rndm-rcount",
                                                    "rndm rcount",
                                                    "Repeat count",
                                                    1.0, 100.0, 1.0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("randomize",
                                                     "randomize",
                                                     "Use random seed",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("seed",
                                                      "seed",
                                                      "Seed value (used only if randomize is FALSE)",
                                                      G_MININT32, G_MAXINT32, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plug-in-randomize-pick
   */
  procedure = picman_procedure_new (plug_in_randomize_pick_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "plug-in-randomize-pick");
  picman_procedure_set_static_strings (procedure,
                                     "plug-in-randomize-pick",
                                     "Randomly interchange some pixels with neighbors",
                                     "This plug-in replaces a pixel with a random adjacent pixel. You may select the percentage of pixels to modify and the number of times to repeat the process.",
                                     "Compatibility procedure. Please see 'gegl:noise-pick' for credits.",
                                     "Compatibility procedure. Please see 'gegl:noise-pick' for credits.",
                                     "2013",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("run-mode",
                                                  "run mode",
                                                  "The run mode",
                                                  PICMAN_TYPE_RUN_MODE,
                                                  PICMAN_RUN_INTERACTIVE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "Input image (unused)",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "Input drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("rndm-pct",
                                                    "rndm pct",
                                                    "Randomization percentage",
                                                    1.0, 100.0, 1.0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("rndm-rcount",
                                                    "rndm rcount",
                                                    "Repeat count",
                                                    1.0, 100.0, 1.0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("randomize",
                                                     "randomize",
                                                     "Use random seed",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("seed",
                                                      "seed",
                                                      "Seed value (used only if randomize is FALSE)",
                                                      G_MININT32, G_MAXINT32, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plug-in-randomize-slur
   */
  procedure = picman_procedure_new (plug_in_randomize_slur_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "plug-in-randomize-slur");
  picman_procedure_set_static_strings (procedure,
                                     "plug-in-randomize-slur",
                                     "Randomly slide some pixels downward (similar to melting",
                                     "This plug-in \"slurs\" (melts like a bunch of icicles) an image. You may select the percentage of pixels to modify and the number of times to repeat the process.",
                                     "Compatibility procedure. Please see 'gegl:noise-slur' for credits.",
                                     "Compatibility procedure. Please see 'gegl:noise-slur' for credits.",
                                     "2013",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("run-mode",
                                                  "run mode",
                                                  "The run mode",
                                                  PICMAN_TYPE_RUN_MODE,
                                                  PICMAN_RUN_INTERACTIVE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "Input image (unused)",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "Input drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("rndm-pct",
                                                    "rndm pct",
                                                    "Randomization percentage",
                                                    1.0, 100.0, 1.0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("rndm-rcount",
                                                    "rndm rcount",
                                                    "Repeat count",
                                                    1.0, 100.0, 1.0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("randomize",
                                                     "randomize",
                                                     "Use random seed",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("seed",
                                                      "seed",
                                                      "Seed value (used only if randomize is FALSE)",
                                                      G_MININT32, G_MAXINT32, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plug-in-semiflatten
   */
  procedure = picman_procedure_new (plug_in_semiflatten_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "plug-in-semiflatten");
  picman_procedure_set_static_strings (procedure,
                                     "plug-in-semiflatten",
                                     "Replace partial transparency with the current background color",
                                     "This plugin flattens pixels in an RGBA image that aren't completely transparent against the current PICMAN background color.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("run-mode",
                                                  "run mode",
                                                  "The run mode",
                                                  PICMAN_TYPE_RUN_MODE,
                                                  PICMAN_RUN_INTERACTIVE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "Input image (unused)",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "Input drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plug-in-threshold-alpha
   */
  procedure = picman_procedure_new (plug_in_threshold_alpha_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "plug-in-threshold-alpha");
  picman_procedure_set_static_strings (procedure,
                                     "plug-in-threshold-alpha",
                                     "Make transparency all-or-nothing",
                                     "Make transparency all-or-nothing.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("run-mode",
                                                  "run mode",
                                                  "The run mode",
                                                  PICMAN_TYPE_RUN_MODE,
                                                  PICMAN_RUN_INTERACTIVE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "Input image (unused)",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "Input drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("threshold",
                                                      "threshold",
                                                      "Threshold",
                                                      0, 255, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plug-in-vinvert
   */
  procedure = picman_procedure_new (plug_in_vinvert_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "plug-in-vinvert");
  picman_procedure_set_static_strings (procedure,
                                     "plug-in-vinvert",
                                     "Invert the brightness of each pixel",
                                     "This function takes an indexed/RGB image and inverts its 'value' in HSV space. The upshot of this is that the color and saturation at any given point remains the same, but its brightness is effectively inverted. Quite strange. Sometimes produces unpleasant color artifacts on images from lossy sources (ie. JPEG).",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("run-mode",
                                                  "run mode",
                                                  "The run mode",
                                                  PICMAN_TYPE_RUN_MODE,
                                                  PICMAN_RUN_INTERACTIVE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "Input image (unused)",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "Input drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);
}
