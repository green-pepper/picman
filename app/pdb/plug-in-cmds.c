/* PICMAN - The GNU Image Manipulation Program
 * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl. */

#include "config.h"

#include <stdlib.h>
#include <string.h>

#include <gegl.h>

#include <gdk-pixbuf/gdk-pixbuf.h>

#include "libpicmanbase/picmanbase.h"

#include "libpicmanbase/picmanbase.h"

#include "pdb-types.h"

#include "core/picman.h"
#include "core/picmanparamspecs.h"
#include "plug-in/picmanplugin.h"
#include "plug-in/picmanplugindef.h"
#include "plug-in/picmanpluginmanager-menu-branch.h"
#include "plug-in/picmanpluginmanager-query.h"
#include "plug-in/picmanpluginmanager.h"
#include "plug-in/picmanpluginprocedure.h"

#include "picmanpdb.h"
#include "picmanprocedure.h"
#include "internal-procs.h"


static PicmanValueArray *
plugins_query_invoker (PicmanProcedure         *procedure,
                       Picman                  *picman,
                       PicmanContext           *context,
                       PicmanProgress          *progress,
                       const PicmanValueArray  *args,
                       GError               **error)
{
  PicmanValueArray *return_vals;
  const gchar *search_string;
  gint32 num_plugins = 0;
  gchar **menu_path = NULL;
  gchar **plugin_accelerator = NULL;
  gchar **plugin_location = NULL;
  gchar **plugin_image_type = NULL;
  gint32 *plugin_install_time = NULL;
  gchar **plugin_real_name = NULL;

  search_string = g_value_get_string (picman_value_array_index (args, 0));

  num_plugins = picman_plug_in_manager_query (picman->plug_in_manager,
                                            search_string,
                                            &menu_path,
                                            &plugin_accelerator,
                                            &plugin_location,
                                            &plugin_image_type,
                                            &plugin_real_name,
                                            &plugin_install_time);

  return_vals = picman_procedure_get_return_values (procedure, TRUE, NULL);

  g_value_set_int (picman_value_array_index (return_vals, 1), num_plugins);
  picman_value_take_stringarray (picman_value_array_index (return_vals, 2), menu_path, num_plugins);
  g_value_set_int (picman_value_array_index (return_vals, 3), num_plugins);
  picman_value_take_stringarray (picman_value_array_index (return_vals, 4), plugin_accelerator, num_plugins);
  g_value_set_int (picman_value_array_index (return_vals, 5), num_plugins);
  picman_value_take_stringarray (picman_value_array_index (return_vals, 6), plugin_location, num_plugins);
  g_value_set_int (picman_value_array_index (return_vals, 7), num_plugins);
  picman_value_take_stringarray (picman_value_array_index (return_vals, 8), plugin_image_type, num_plugins);
  g_value_set_int (picman_value_array_index (return_vals, 9), num_plugins);
  picman_value_take_int32array (picman_value_array_index (return_vals, 10), plugin_install_time, num_plugins);
  g_value_set_int (picman_value_array_index (return_vals, 11), num_plugins);
  picman_value_take_stringarray (picman_value_array_index (return_vals, 12), plugin_real_name, num_plugins);

  return return_vals;
}

static PicmanValueArray *
plugin_domain_register_invoker (PicmanProcedure         *procedure,
                                Picman                  *picman,
                                PicmanContext           *context,
                                PicmanProgress          *progress,
                                const PicmanValueArray  *args,
                                GError               **error)
{
  gboolean success = TRUE;
  const gchar *domain_name;
  const gchar *domain_path;

  domain_name = g_value_get_string (picman_value_array_index (args, 0));
  domain_path = g_value_get_string (picman_value_array_index (args, 1));

  if (success)
    {
      PicmanPlugIn *plug_in = picman->plug_in_manager->current_plug_in;

      if (plug_in && plug_in->call_mode == PICMAN_PLUG_IN_CALL_QUERY)
        {
          picman_plug_in_def_set_locale_domain (plug_in->plug_in_def,
                                              domain_name, domain_path);
        }
      else
        {
          success = FALSE;
        }
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plugin_help_register_invoker (PicmanProcedure         *procedure,
                              Picman                  *picman,
                              PicmanContext           *context,
                              PicmanProgress          *progress,
                              const PicmanValueArray  *args,
                              GError               **error)
{
  gboolean success = TRUE;
  const gchar *domain_name;
  const gchar *domain_uri;

  domain_name = g_value_get_string (picman_value_array_index (args, 0));
  domain_uri = g_value_get_string (picman_value_array_index (args, 1));

  if (success)
    {
      PicmanPlugIn *plug_in = picman->plug_in_manager->current_plug_in;

      if (plug_in && plug_in->call_mode == PICMAN_PLUG_IN_CALL_QUERY)
        {
          picman_plug_in_def_set_help_domain (plug_in->plug_in_def,
                                            domain_name, domain_uri);
        }
      else
        {
          success = FALSE;
        }
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plugin_menu_register_invoker (PicmanProcedure         *procedure,
                              Picman                  *picman,
                              PicmanContext           *context,
                              PicmanProgress          *progress,
                              const PicmanValueArray  *args,
                              GError               **error)
{
  gboolean success = TRUE;
  const gchar *procedure_name;
  const gchar *menu_path;

  procedure_name = g_value_get_string (picman_value_array_index (args, 0));
  menu_path = g_value_get_string (picman_value_array_index (args, 1));

  if (success)
    {
      PicmanPlugIn *plug_in = picman->plug_in_manager->current_plug_in;

      if (plug_in)
        {
          gchar *canonical = picman_canonicalize_identifier (procedure_name);
          success = picman_plug_in_menu_register (plug_in, canonical, menu_path);
          g_free (canonical);
        }
      else
        {
          success = FALSE;
        }
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plugin_menu_branch_register_invoker (PicmanProcedure         *procedure,
                                     Picman                  *picman,
                                     PicmanContext           *context,
                                     PicmanProgress          *progress,
                                     const PicmanValueArray  *args,
                                     GError               **error)
{
  gboolean success = TRUE;
  const gchar *menu_path;
  const gchar *menu_name;

  menu_path = g_value_get_string (picman_value_array_index (args, 0));
  menu_name = g_value_get_string (picman_value_array_index (args, 1));

  if (success)
    {
      PicmanPlugIn *plug_in = picman->plug_in_manager->current_plug_in;

      if (plug_in)
        {
          picman_plug_in_manager_add_menu_branch (picman->plug_in_manager,
                                                plug_in->prog, menu_path, menu_name);
        }
      else
        {
          success = FALSE;
        }
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plugin_icon_register_invoker (PicmanProcedure         *procedure,
                              Picman                  *picman,
                              PicmanContext           *context,
                              PicmanProgress          *progress,
                              const PicmanValueArray  *args,
                              GError               **error)
{
  gboolean success = TRUE;
  const gchar *procedure_name;
  gint32 icon_type;
  gint32 icon_data_length;
  const guint8 *icon_data;

  procedure_name = g_value_get_string (picman_value_array_index (args, 0));
  icon_type = g_value_get_enum (picman_value_array_index (args, 1));
  icon_data_length = g_value_get_int (picman_value_array_index (args, 2));
  icon_data = picman_value_get_int8array (picman_value_array_index (args, 3));

  if (success)
    {
      PicmanPlugIn *plug_in = picman->plug_in_manager->current_plug_in;

      if (plug_in && plug_in->call_mode == PICMAN_PLUG_IN_CALL_QUERY)
        {
          PicmanPlugInProcedure *proc;
          gchar               *canonical;

          canonical = picman_canonicalize_identifier (procedure_name);

          proc = picman_plug_in_procedure_find (plug_in->plug_in_def->procedures,
                                              canonical);

          g_free (canonical);

          if (proc)
            picman_plug_in_procedure_set_icon (proc, icon_type,
                                             icon_data, icon_data_length);
          else
            success = FALSE;
        }
      else
        {
          success = FALSE;
        }
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plugin_set_pdb_error_handler_invoker (PicmanProcedure         *procedure,
                                      Picman                  *picman,
                                      PicmanContext           *context,
                                      PicmanProgress          *progress,
                                      const PicmanValueArray  *args,
                                      GError               **error)
{
  gboolean success = TRUE;
  gint32 handler;

  handler = g_value_get_enum (picman_value_array_index (args, 0));

  if (success)
    {
      PicmanPlugIn *plug_in = picman->plug_in_manager->current_plug_in;

      if (plug_in)
        {
          picman_plug_in_set_error_handler (plug_in, handler);
        }
      else
        {
          success = FALSE;
        }
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plugin_get_pdb_error_handler_invoker (PicmanProcedure         *procedure,
                                      Picman                  *picman,
                                      PicmanContext           *context,
                                      PicmanProgress          *progress,
                                      const PicmanValueArray  *args,
                                      GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  gint32 handler = 0;

  PicmanPlugIn *plug_in = picman->plug_in_manager->current_plug_in;

  if (plug_in)
    {
      handler = picman_plug_in_get_error_handler (plug_in);
    }
  else
    {
      success = FALSE;
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_enum (picman_value_array_index (return_vals, 1), handler);

  return return_vals;
}

static PicmanValueArray *
plugin_enable_precision_invoker (PicmanProcedure         *procedure,
                                 Picman                  *picman,
                                 PicmanContext           *context,
                                 PicmanProgress          *progress,
                                 const PicmanValueArray  *args,
                                 GError               **error)
{
  gboolean success = TRUE;
  PicmanPlugIn *plug_in = picman->plug_in_manager->current_plug_in;

  if (plug_in)
    {
      picman_plug_in_enable_precision (plug_in);
    }
  else
    {
      success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
plugin_precision_enabled_invoker (PicmanProcedure         *procedure,
                                  Picman                  *picman,
                                  PicmanContext           *context,
                                  PicmanProgress          *progress,
                                  const PicmanValueArray  *args,
                                  GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  gboolean enabled = FALSE;

  PicmanPlugIn *plug_in = picman->plug_in_manager->current_plug_in;

  if (plug_in)
    {
      enabled = picman_plug_in_precision_enabled (plug_in);
    }
  else
    {
      success = FALSE;
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), enabled);

  return return_vals;
}

void
register_plug_in_procs (PicmanPDB *pdb)
{
  PicmanProcedure *procedure;

  /*
   * picman-plugins-query
   */
  procedure = picman_procedure_new (plugins_query_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-plugins-query");
  picman_procedure_set_static_strings (procedure,
                                     "picman-plugins-query",
                                     "Queries the plugin database for its contents.",
                                     "This procedure queries the contents of the plugin database.",
                                     "Andy Thomas",
                                     "Andy Thomas",
                                     "1998",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("search-string",
                                                       "search string",
                                                       "If not an empty string then use this as a search pattern",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE | PICMAN_PARAM_NO_VALIDATE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_int32 ("num-plugins",
                                                          "num plugins",
                                                          "The number of plugins",
                                                          0, G_MAXINT32, 0,
                                                          PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_string_array ("menu-path",
                                                                 "menu path",
                                                                 "The menu path of the plugin",
                                                                 PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_int32 ("num-plugins",
                                                          "num plugins",
                                                          "The number of plugins",
                                                          0, G_MAXINT32, 0,
                                                          PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_string_array ("plugin-accelerator",
                                                                 "plugin accelerator",
                                                                 "String representing keyboard accelerator (could be empty string)",
                                                                 PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_int32 ("num-plugins",
                                                          "num plugins",
                                                          "The number of plugins",
                                                          0, G_MAXINT32, 0,
                                                          PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_string_array ("plugin-location",
                                                                 "plugin location",
                                                                 "Location of the plugin program",
                                                                 PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_int32 ("num-plugins",
                                                          "num plugins",
                                                          "The number of plugins",
                                                          0, G_MAXINT32, 0,
                                                          PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_string_array ("plugin-image-type",
                                                                 "plugin image type",
                                                                 "Type of image that this plugin will work on",
                                                                 PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_int32 ("num-plugins",
                                                          "num plugins",
                                                          "The number of plugins",
                                                          0, G_MAXINT32, 0,
                                                          PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_int32_array ("plugin-install-time",
                                                                "plugin install time",
                                                                "Time that the plugin was installed",
                                                                PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_int32 ("num-plugins",
                                                          "num plugins",
                                                          "The number of plugins",
                                                          0, G_MAXINT32, 0,
                                                          PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_string_array ("plugin-real-name",
                                                                 "plugin real name",
                                                                 "The internal name of the plugin",
                                                                 PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plugin-domain-register
   */
  procedure = picman_procedure_new (plugin_domain_register_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-plugin-domain-register");
  picman_procedure_set_static_strings (procedure,
                                     "picman-plugin-domain-register",
                                     "Registers a textdomain for localisation.",
                                     "This procedure adds a textdomain to the list of domains Picman searches for strings when translating its menu entries. There is no need to call this function for plug-ins that have their strings included in the 'picman-std-plugins' domain as that is used by default. If the compiled message catalog is not in the standard location, you may specify an absolute path to another location. This procedure can only be called in the query function of a plug-in and it has to be called before any procedure is installed.",
                                     "Sven Neumann <sven@picman.org>",
                                     "Sven Neumann",
                                     "2000",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("domain-name",
                                                       "domain name",
                                                       "The name of the textdomain (must be unique)",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("domain-path",
                                                       "domain path",
                                                       "The absolute path to the compiled message catalog (may be NULL)",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE | PICMAN_PARAM_NO_VALIDATE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plugin-help-register
   */
  procedure = picman_procedure_new (plugin_help_register_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-plugin-help-register");
  picman_procedure_set_static_strings (procedure,
                                     "picman-plugin-help-register",
                                     "Register a help path for a plug-in.",
                                     "This procedure registers user documentation for the calling plug-in with the PICMAN help system. The domain_uri parameter points to the root directory where the plug-in help is installed. For each supported language there should be a file called 'picman-help.xml' that maps the help IDs to the actual help files.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2000",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("domain-name",
                                                       "domain name",
                                                       "The XML namespace of the plug-in's help pages",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("domain-uri",
                                                       "domain uri",
                                                       "The root URI of the plug-in's help pages",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plugin-menu-register
   */
  procedure = picman_procedure_new (plugin_menu_register_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-plugin-menu-register");
  picman_procedure_set_static_strings (procedure,
                                     "picman-plugin-menu-register",
                                     "Register an additional menu path for a plug-in procedure.",
                                     "This procedure installs an additional menu entry for the given procedure.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2004",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("procedure-name",
                                                       "procedure name",
                                                       "The procedure for which to install the menu path",
                                                       FALSE, FALSE, TRUE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("menu-path",
                                                       "menu path",
                                                       "The procedure's additional menu path",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plugin-menu-branch-register
   */
  procedure = picman_procedure_new (plugin_menu_branch_register_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-plugin-menu-branch-register");
  picman_procedure_set_static_strings (procedure,
                                     "picman-plugin-menu-branch-register",
                                     "Register a sub-menu.",
                                     "This procedure installs a sub-menu which does not belong to any procedure. The menu-name should be the untranslated menu label. PICMAN will look up the translation in the textdomain registered for the plug-in.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2005",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("menu-path",
                                                       "menu path",
                                                       "The sub-menu's menu path",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("menu-name",
                                                       "menu name",
                                                       "The name of the sub-menu",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plugin-icon-register
   */
  procedure = picman_procedure_new (plugin_icon_register_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-plugin-icon-register");
  picman_procedure_set_static_strings (procedure,
                                     "picman-plugin-icon-register",
                                     "Register an icon for a plug-in procedure.",
                                     "This procedure installs an icon for the given procedure.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2004",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("procedure-name",
                                                       "procedure name",
                                                       "The procedure for which to install the icon",
                                                       FALSE, FALSE, TRUE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("icon-type",
                                                  "icon type",
                                                  "The type of the icon",
                                                  PICMAN_TYPE_ICON_TYPE,
                                                  PICMAN_ICON_TYPE_STOCK_ID,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("icon-data-length",
                                                      "icon data length",
                                                      "The length of 'icon-data'",
                                                      1, G_MAXINT32, 1,
                                                      PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int8_array ("icon-data",
                                                           "icon data",
                                                           "The procedure's icon. The format depends on the 'icon_type' parameter",
                                                           PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plugin-set-pdb-error-handler
   */
  procedure = picman_procedure_new (plugin_set_pdb_error_handler_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-plugin-set-pdb-error-handler");
  picman_procedure_set_static_strings (procedure,
                                     "picman-plugin-set-pdb-error-handler",
                                     "Sets an error handler for procedure calls.",
                                     "This procedure changes the way that errors in procedure calls are handled. By default PICMAN will raise an error dialog if a procedure call made by a plug-in fails. Using this procedure the plug-in can change this behavior. If the error handler is set to %PICMAN_PDB_ERROR_HANDLER_PLUGIN, then the plug-in is responsible for calling 'picman-get-pdb-error' and handling the error whenever one if its procedure calls fails. It can do this by displaying the error message or by forwarding it in its own return values.",
                                     "Sven Neumann <sven@picman.org>",
                                     "Sven Neumann",
                                     "2008",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("handler",
                                                  "handler",
                                                  "Who is responsible for handling procedure call errors",
                                                  PICMAN_TYPE_PDB_ERROR_HANDLER,
                                                  PICMAN_PDB_ERROR_HANDLER_INTERNAL,
                                                  PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plugin-get-pdb-error-handler
   */
  procedure = picman_procedure_new (plugin_get_pdb_error_handler_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-plugin-get-pdb-error-handler");
  picman_procedure_set_static_strings (procedure,
                                     "picman-plugin-get-pdb-error-handler",
                                     "Retrieves the active error handler for procedure calls.",
                                     "This procedure retrieves the currently active error handler for procedure calls made by the calling plug-in. See 'picman-plugin-set-pdb-error-handler' for details.",
                                     "Sven Neumann <sven@picman.org>",
                                     "Sven Neumann",
                                     "2008",
                                     NULL);
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_enum ("handler",
                                                      "handler",
                                                      "Who is responsible for handling procedure call errors",
                                                      PICMAN_TYPE_PDB_ERROR_HANDLER,
                                                      PICMAN_PDB_ERROR_HANDLER_INTERNAL,
                                                      PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plugin-enable-precision
   */
  procedure = picman_procedure_new (plugin_enable_precision_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-plugin-enable-precision");
  picman_procedure_set_static_strings (procedure,
                                     "picman-plugin-enable-precision",
                                     "Switches this plug-in to using the real bit depth of drawables.",
                                     "Switches this plug-in to using the real bit depth of drawables. This setting can only be enabled, and not disabled again during the lifetime of the plug-in. Using 'picman-drawable-get-buffer', 'picman-drawable-get-shadow-buffer' or 'picman-drawable-get-format' will automatically call this function.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2012",
                                     NULL);
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-plugin-precision-enabled
   */
  procedure = picman_procedure_new (plugin_precision_enabled_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-plugin-precision-enabled");
  picman_procedure_set_static_strings (procedure,
                                     "picman-plugin-precision-enabled",
                                     "Whether this plug-in is using the real bit depth of drawables.",
                                     "Returns whether this plug-in is using the real bit depth of drawables, which can be more than 8 bits per channel.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2012",
                                     NULL);
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("enabled",
                                                         "enabled",
                                                         "Whether precision is enabled",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);
}
