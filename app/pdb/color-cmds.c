/* PICMAN - The GNU Image Manipulation Program
 * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl. */

#include "config.h"

#include <gegl.h>

#include <gdk-pixbuf/gdk-pixbuf.h>

#include "libpicmanbase/picmanbase.h"

#include "pdb-types.h"

#include "core/picmandrawable-equalize.h"
#include "core/picmandrawable-histogram.h"
#include "core/picmandrawable-levels.h"
#include "core/picmandrawable-operation.h"
#include "core/picmandrawable.h"
#include "core/picmanhistogram.h"
#include "core/picmanparamspecs.h"
#include "operations/picmanbrightnesscontrastconfig.h"
#include "operations/picmancolorbalanceconfig.h"
#include "operations/picmancolorizeconfig.h"
#include "operations/picmancurvesconfig.h"
#include "operations/picmandesaturateconfig.h"
#include "operations/picmanhuesaturationconfig.h"
#include "operations/picmanlevelsconfig.h"
#include "operations/picmanposterizeconfig.h"
#include "operations/picmanthresholdconfig.h"

#include "picmanpdb.h"
#include "picmanpdb-utils.h"
#include "picmanprocedure.h"
#include "internal-procs.h"

#include "picman-intl.h"


static PicmanValueArray *
brightness_contrast_invoker (PicmanProcedure         *procedure,
                             Picman                  *picman,
                             PicmanContext           *context,
                             PicmanProgress          *progress,
                             const PicmanValueArray  *args,
                             GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 brightness;
  gint32 contrast;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  brightness = g_value_get_int (picman_value_array_index (args, 1));
  contrast = g_value_get_int (picman_value_array_index (args, 2));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          GObject *config = g_object_new (PICMAN_TYPE_BRIGHTNESS_CONTRAST_CONFIG,
                                          "brightness", brightness / 127.0,
                                          "contrast",   contrast   / 127.0,
                                          NULL);

          picman_drawable_apply_operation_by_name (drawable, progress,
                                                 C_("undo-type", "Brightness-Contrast"),
                                                 "picman:brightness-contrast",
                                                 config);
          g_object_unref (config);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
levels_invoker (PicmanProcedure         *procedure,
                Picman                  *picman,
                PicmanContext           *context,
                PicmanProgress          *progress,
                const PicmanValueArray  *args,
                GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 channel;
  gint32 low_input;
  gint32 high_input;
  gdouble gamma;
  gint32 low_output;
  gint32 high_output;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  channel = g_value_get_enum (picman_value_array_index (args, 1));
  low_input = g_value_get_int (picman_value_array_index (args, 2));
  high_input = g_value_get_int (picman_value_array_index (args, 3));
  gamma = g_value_get_double (picman_value_array_index (args, 4));
  low_output = g_value_get_int (picman_value_array_index (args, 5));
  high_output = g_value_get_int (picman_value_array_index (args, 6));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error) &&
          (picman_drawable_has_alpha (drawable) || channel != PICMAN_HISTOGRAM_ALPHA) &&
          (! picman_drawable_is_gray (drawable) ||
           channel == PICMAN_HISTOGRAM_VALUE || channel == PICMAN_HISTOGRAM_ALPHA))
        {
          GObject *config = g_object_new (PICMAN_TYPE_LEVELS_CONFIG,
                                          "channel", channel,
                                          NULL);

          g_object_set (config,
                        "low-input",   low_input   / 255.0,
                        "high-input",  high_input  / 255.0,
                        "gamma",       gamma,
                        "low-output",  low_output  / 255.0,
                        "high-output", high_output / 255.0,
                        NULL);

          picman_drawable_apply_operation_by_name (drawable, progress,
                                                 C_("undo-type", "Levels"),
                                                 "picman:levels",
                                                 config);
          g_object_unref (config);
        }
      else
        success = TRUE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
levels_auto_invoker (PicmanProcedure         *procedure,
                     Picman                  *picman,
                     PicmanContext           *context,
                     PicmanProgress          *progress,
                     const PicmanValueArray  *args,
                     GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          picman_drawable_levels_stretch (drawable, progress);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
levels_stretch_invoker (PicmanProcedure         *procedure,
                        Picman                  *picman,
                        PicmanContext           *context,
                        PicmanProgress          *progress,
                        const PicmanValueArray  *args,
                        GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          picman_drawable_levels_stretch (drawable, progress);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
posterize_invoker (PicmanProcedure         *procedure,
                   Picman                  *picman,
                   PicmanContext           *context,
                   PicmanProgress          *progress,
                   const PicmanValueArray  *args,
                   GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 levels;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  levels = g_value_get_int (picman_value_array_index (args, 1));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          GObject *config = g_object_new (PICMAN_TYPE_POSTERIZE_CONFIG,
                                          "levels", levels,
                                          NULL);

          picman_drawable_apply_operation_by_name (drawable, progress,
                                                 _("Posterize"),
                                                 "picman:posterize",
                                                 config);
          g_object_unref (config);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
desaturate_invoker (PicmanProcedure         *procedure,
                    Picman                  *picman,
                    PicmanContext           *context,
                    PicmanProgress          *progress,
                    const PicmanValueArray  *args,
                    GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error) &&
          picman_drawable_is_rgb (drawable))
        {
          GObject *config = g_object_new (PICMAN_TYPE_DESATURATE_CONFIG,
                                          "mode", PICMAN_DESATURATE_LIGHTNESS,
                                          NULL);

          picman_drawable_apply_operation_by_name (drawable, progress,
                                                 _("Desaturate"),
                                                 "picman:desaturate",
                                                 config);
          g_object_unref (config);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
desaturate_full_invoker (PicmanProcedure         *procedure,
                         Picman                  *picman,
                         PicmanContext           *context,
                         PicmanProgress          *progress,
                         const PicmanValueArray  *args,
                         GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 desaturate_mode;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  desaturate_mode = g_value_get_enum (picman_value_array_index (args, 1));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error) &&
          picman_drawable_is_rgb (drawable))
        {
          GObject *config = g_object_new (PICMAN_TYPE_DESATURATE_CONFIG,
                                          "mode", desaturate_mode,
                                          NULL);

          picman_drawable_apply_operation_by_name (drawable, progress,
                                                 _("Desaturate"),
                                                 "picman:desaturate",
                                                 config);
          g_object_unref (config);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
equalize_invoker (PicmanProcedure         *procedure,
                  Picman                  *picman,
                  PicmanContext           *context,
                  PicmanProgress          *progress,
                  const PicmanValueArray  *args,
                  GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gboolean mask_only;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  mask_only = g_value_get_boolean (picman_value_array_index (args, 1));

  if (success)
    {
      if (! picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                       PICMAN_PDB_ITEM_CONTENT, error) ||
          ! picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        success = FALSE;

      if (success)
        picman_drawable_equalize (drawable, mask_only);
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
invert_invoker (PicmanProcedure         *procedure,
                Picman                  *picman,
                PicmanContext           *context,
                PicmanProgress          *progress,
                const PicmanValueArray  *args,
                GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          picman_drawable_apply_operation_by_name (drawable, progress,
                                                 _("Invert"),
                                                 "gegl:invert",
                                                 NULL);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
curves_spline_invoker (PicmanProcedure         *procedure,
                       Picman                  *picman,
                       PicmanContext           *context,
                       PicmanProgress          *progress,
                       const PicmanValueArray  *args,
                       GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 channel;
  gint32 num_points;
  const guint8 *control_pts;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  channel = g_value_get_enum (picman_value_array_index (args, 1));
  num_points = g_value_get_int (picman_value_array_index (args, 2));
  control_pts = picman_value_get_int8array (picman_value_array_index (args, 3));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error) &&
          ! (num_points & 1) &&
          (picman_drawable_has_alpha (drawable) || channel != PICMAN_HISTOGRAM_ALPHA) &&
          (! picman_drawable_is_gray (drawable) ||
           channel == PICMAN_HISTOGRAM_VALUE || channel == PICMAN_HISTOGRAM_ALPHA))
        {
          GObject *config = picman_curves_config_new_spline (channel,
                                                           control_pts,
                                                           num_points);

          picman_drawable_apply_operation_by_name (drawable, progress,
                                                 C_("undo-type", "Curves"),
                                                 "picman:curves",
                                                 config);
          g_object_unref (config);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
curves_explicit_invoker (PicmanProcedure         *procedure,
                         Picman                  *picman,
                         PicmanContext           *context,
                         PicmanProgress          *progress,
                         const PicmanValueArray  *args,
                         GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 channel;
  gint32 num_bytes;
  const guint8 *curve;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  channel = g_value_get_enum (picman_value_array_index (args, 1));
  num_bytes = g_value_get_int (picman_value_array_index (args, 2));
  curve = picman_value_get_int8array (picman_value_array_index (args, 3));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error) &&
          (num_bytes == 256) &&
          (picman_drawable_has_alpha (drawable) || channel != PICMAN_HISTOGRAM_ALPHA) &&
          (! picman_drawable_is_gray (drawable) ||
           channel == PICMAN_HISTOGRAM_VALUE || channel == PICMAN_HISTOGRAM_ALPHA))
        {
          GObject *config = picman_curves_config_new_spline (channel,
                                                           curve,
                                                           num_bytes);

          picman_drawable_apply_operation_by_name (drawable, progress,
                                                 C_("undo-type", "Curves"),
                                                 "picman:curves",
                                                 config);
          g_object_unref (config);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
color_balance_invoker (PicmanProcedure         *procedure,
                       Picman                  *picman,
                       PicmanContext           *context,
                       PicmanProgress          *progress,
                       const PicmanValueArray  *args,
                       GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 transfer_mode;
  gboolean preserve_lum;
  gdouble cyan_red;
  gdouble magenta_green;
  gdouble yellow_blue;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  transfer_mode = g_value_get_enum (picman_value_array_index (args, 1));
  preserve_lum = g_value_get_boolean (picman_value_array_index (args, 2));
  cyan_red = g_value_get_double (picman_value_array_index (args, 3));
  magenta_green = g_value_get_double (picman_value_array_index (args, 4));
  yellow_blue = g_value_get_double (picman_value_array_index (args, 5));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error)  &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          GObject *config = g_object_new (PICMAN_TYPE_COLORIZE_CONFIG,
                                          "range",               transfer_mode,
                                          "preserve-luminosity", preserve_lum,
                                          NULL);

          g_object_set (config,
                        "cyan-red",      cyan_red      / 100.0,
                        "magenta-green", magenta_green / 100.0,
                        "yellow-blue",   yellow_blue   / 100.0,
                        NULL);

          picman_drawable_apply_operation_by_name (drawable, progress,
                                                 C_("undo-type", "Color Balance"),
                                                 "picman:color-balance",
                                                 config);
          g_object_unref (config);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
colorize_invoker (PicmanProcedure         *procedure,
                  Picman                  *picman,
                  PicmanContext           *context,
                  PicmanProgress          *progress,
                  const PicmanValueArray  *args,
                  GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gdouble hue;
  gdouble saturation;
  gdouble lightness;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  hue = g_value_get_double (picman_value_array_index (args, 1));
  saturation = g_value_get_double (picman_value_array_index (args, 2));
  lightness = g_value_get_double (picman_value_array_index (args, 3));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error) &&
          ! picman_drawable_is_gray (drawable))
        {
          GObject *config = g_object_new (PICMAN_TYPE_COLORIZE_CONFIG,
                                          "hue",        hue        / 360.0,
                                          "saturation", saturation / 100.0,
                                          "lightness",  lightness  / 100.0,
                                          NULL);

          picman_drawable_apply_operation_by_name (drawable, progress,
                                                 C_("undo-type", "Colorize"),
                                                 "picman:colorize",
                                                 config);
          g_object_unref (config);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
histogram_invoker (PicmanProcedure         *procedure,
                   Picman                  *picman,
                   PicmanContext           *context,
                   PicmanProgress          *progress,
                   const PicmanValueArray  *args,
                   GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanDrawable *drawable;
  gint32 channel;
  gint32 start_range;
  gint32 end_range;
  gdouble mean = 0.0;
  gdouble std_dev = 0.0;
  gdouble median = 0.0;
  gdouble pixels = 0.0;
  gdouble count = 0.0;
  gdouble percentile = 0.0;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  channel = g_value_get_enum (picman_value_array_index (args, 1));
  start_range = g_value_get_int (picman_value_array_index (args, 2));
  end_range = g_value_get_int (picman_value_array_index (args, 3));

  if (success)
    {
      if (! picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL, 0, error) ||
          picman_drawable_is_indexed (drawable) ||
          (! picman_drawable_has_alpha (drawable) &&
           channel == PICMAN_HISTOGRAM_ALPHA) ||
          (picman_drawable_is_gray (drawable) &&
           channel != PICMAN_HISTOGRAM_VALUE && channel != PICMAN_HISTOGRAM_ALPHA))
        success = FALSE;

      if (success)
        {
          PicmanHistogram *histogram = picman_histogram_new ();

          picman_drawable_calculate_histogram (drawable, histogram);

          mean       = picman_histogram_get_mean (histogram, channel,
                                                 start_range, end_range);
          std_dev    = picman_histogram_get_std_dev (histogram, channel,
                                                   start_range, end_range);
          median     = picman_histogram_get_median (histogram, channel,
                                                  start_range, end_range);
          pixels     = picman_histogram_get_count (histogram, channel, 0, 255);
          count      = picman_histogram_get_count (histogram, channel,
                                                 start_range, end_range);
          percentile = count / pixels;

          picman_histogram_unref (histogram);
        }
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    {
      g_value_set_double (picman_value_array_index (return_vals, 1), mean);
      g_value_set_double (picman_value_array_index (return_vals, 2), std_dev);
      g_value_set_double (picman_value_array_index (return_vals, 3), median);
      g_value_set_double (picman_value_array_index (return_vals, 4), pixels);
      g_value_set_double (picman_value_array_index (return_vals, 5), count);
      g_value_set_double (picman_value_array_index (return_vals, 6), percentile);
    }

  return return_vals;
}

static PicmanValueArray *
hue_saturation_invoker (PicmanProcedure         *procedure,
                        Picman                  *picman,
                        PicmanContext           *context,
                        PicmanProgress          *progress,
                        const PicmanValueArray  *args,
                        GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 hue_range;
  gdouble hue_offset;
  gdouble lightness;
  gdouble saturation;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  hue_range = g_value_get_enum (picman_value_array_index (args, 1));
  hue_offset = g_value_get_double (picman_value_array_index (args, 2));
  lightness = g_value_get_double (picman_value_array_index (args, 3));
  saturation = g_value_get_double (picman_value_array_index (args, 4));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          GObject *config = g_object_new (PICMAN_TYPE_HUE_SATURATION_CONFIG,
                                          "range", hue_range,
                                          NULL);

           g_object_set (config,
                         "hue",        hue_offset / 180.0,
                         "saturation", saturation / 100.0,
                         "lightness",  lightness  / 100.0,
                         NULL);

          picman_drawable_apply_operation_by_name (drawable, progress,
                                                 _("Hue-Saturation"),
                                                 "picman:hue-saturation",
                                                 config);
          g_object_unref (config);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
threshold_invoker (PicmanProcedure         *procedure,
                   Picman                  *picman,
                   PicmanContext           *context,
                   PicmanProgress          *progress,
                   const PicmanValueArray  *args,
                   GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 low_threshold;
  gint32 high_threshold;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  low_threshold = g_value_get_int (picman_value_array_index (args, 1));
  high_threshold = g_value_get_int (picman_value_array_index (args, 2));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          GObject *config = g_object_new (PICMAN_TYPE_THRESHOLD_CONFIG,
                                          "low",  low_threshold  / 255.0,
                                          "high", high_threshold / 255.0,
                                          NULL);

          picman_drawable_apply_operation_by_name (drawable, progress,
                                                 _("Threshold"),
                                                 "picman:threshold",
                                                 config);
          g_object_unref (config);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

void
register_color_procs (PicmanPDB *pdb)
{
  PicmanProcedure *procedure;

  /*
   * picman-brightness-contrast
   */
  procedure = picman_procedure_new (brightness_contrast_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-brightness-contrast");
  picman_procedure_set_static_strings (procedure,
                                     "picman-brightness-contrast",
                                     "Modify brightness/contrast in the specified drawable.",
                                     "This procedures allows the brightness and contrast of the specified drawable to be modified. Both 'brightness' and 'contrast' parameters are defined between -127 and 127.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("brightness",
                                                      "brightness",
                                                      "Brightness adjustment",
                                                      -127, 127, -127,
                                                      PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("contrast",
                                                      "contrast",
                                                      "Contrast adjustment",
                                                      -127, 127, -127,
                                                      PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-levels
   */
  procedure = picman_procedure_new (levels_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-levels");
  picman_procedure_set_static_strings (procedure,
                                     "picman-levels",
                                     "Modifies intensity levels in the specified drawable.",
                                     "This tool allows intensity levels in the specified drawable to be remapped according to a set of parameters. The low/high input levels specify an initial mapping from the source intensities. The gamma value determines how intensities between the low and high input intensities are interpolated. A gamma value of 1.0 results in a linear interpolation. Higher gamma values result in more high-level intensities. Lower gamma values result in more low-level intensities. The low/high output levels constrain the final intensity mapping--that is, no final intensity will be lower than the low output level and no final intensity will be higher than the high output level. This tool is only valid on RGB color and grayscale images.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("channel",
                                                  "channel",
                                                  "The channel to modify",
                                                  PICMAN_TYPE_HISTOGRAM_CHANNEL,
                                                  PICMAN_HISTOGRAM_VALUE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("low-input",
                                                      "low input",
                                                      "Intensity of lowest input",
                                                      0, 255, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("high-input",
                                                      "high input",
                                                      "Intensity of highest input",
                                                      0, 255, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("gamma",
                                                    "gamma",
                                                    "Gamma correction factor",
                                                    0.1, 10, 0.1,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("low-output",
                                                      "low output",
                                                      "Intensity of lowest output",
                                                      0, 255, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("high-output",
                                                      "high output",
                                                      "Intensity of highest output",
                                                      0, 255, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-levels-auto
   */
  procedure = picman_procedure_new (levels_auto_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-levels-auto");
  picman_procedure_set_static_strings (procedure,
                                     "picman-levels-auto",
                                     "Deprecated: Use 'picman-levels-stretch' instead.",
                                     "Deprecated: Use 'picman-levels-stretch' instead.",
                                     "",
                                     "",
                                     "",
                                     "picman-levels-stretch");
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-levels-stretch
   */
  procedure = picman_procedure_new (levels_stretch_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-levels-stretch");
  picman_procedure_set_static_strings (procedure,
                                     "picman-levels-stretch",
                                     "Automatically modifies intensity levels in the specified drawable.",
                                     "This procedure allows intensity levels in the specified drawable to be remapped according to a set of guessed parameters. It is equivalent to clicking the \"Auto\" button in the Levels tool.",
                                     "Joao S.O. Bueno, Shawn Willden",
                                     "Joao S.O. Bueno, Shawn Willden",
                                     "2003",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-posterize
   */
  procedure = picman_procedure_new (posterize_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-posterize");
  picman_procedure_set_static_strings (procedure,
                                     "picman-posterize",
                                     "Posterize the specified drawable.",
                                     "This procedures reduces the number of shades allows in each intensity channel to the specified 'levels' parameter.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("levels",
                                                      "levels",
                                                      "Levels of posterization",
                                                      2, 255, 2,
                                                      PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-desaturate
   */
  procedure = picman_procedure_new (desaturate_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-desaturate");
  picman_procedure_set_static_strings (procedure,
                                     "picman-desaturate",
                                     "Desaturate the contents of the specified drawable.",
                                     "This procedure desaturates the contents of the specified drawable. This procedure only works on drawables of type RGB color.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-desaturate-full
   */
  procedure = picman_procedure_new (desaturate_full_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-desaturate-full");
  picman_procedure_set_static_strings (procedure,
                                     "picman-desaturate-full",
                                     "Desaturate the contents of the specified drawable, with the specified formula.",
                                     "This procedure desaturates the contents of the specified drawable, with the specified formula. This procedure only works on drawables of type RGB color.",
                                     "Karine Delvare",
                                     "Karine Delvare",
                                     "2005",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("desaturate-mode",
                                                  "desaturate mode",
                                                  "The formula to use to desaturate",
                                                  PICMAN_TYPE_DESATURATE_MODE,
                                                  PICMAN_DESATURATE_LIGHTNESS,
                                                  PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-equalize
   */
  procedure = picman_procedure_new (equalize_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-equalize");
  picman_procedure_set_static_strings (procedure,
                                     "picman-equalize",
                                     "Equalize the contents of the specified drawable.",
                                     "This procedure equalizes the contents of the specified drawable. Each intensity channel is equalized independently. The equalized intensity is given as inten' = (255 - inten). The 'mask_only' option specifies whether to adjust only the area of the image within the selection bounds, or the entire image based on the histogram of the selected area. If there is no selection, the entire image is adjusted based on the histogram for the entire image.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("mask-only",
                                                     "mask only",
                                                     "Equalization option",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-invert
   */
  procedure = picman_procedure_new (invert_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-invert");
  picman_procedure_set_static_strings (procedure,
                                     "picman-invert",
                                     "Invert the contents of the specified drawable.",
                                     "This procedure inverts the contents of the specified drawable. Each intensity channel is inverted independently. The inverted intensity is given as inten' = (255 - inten).",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-curves-spline
   */
  procedure = picman_procedure_new (curves_spline_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-curves-spline");
  picman_procedure_set_static_strings (procedure,
                                     "picman-curves-spline",
                                     "Modifies the intensity curve(s) for specified drawable.",
                                     "Modifies the intensity mapping for one channel in the specified drawable. The drawable must be either grayscale or RGB, and the channel can be either an intensity component, or the value. The 'control_pts' parameter is an array of integers which define a set of control points which describe a Catmull Rom spline which yields the final intensity curve. Use the 'picman-curves-explicit' function to explicitly modify intensity levels.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("channel",
                                                  "channel",
                                                  "The channel to modify",
                                                  PICMAN_TYPE_HISTOGRAM_CHANNEL,
                                                  PICMAN_HISTOGRAM_VALUE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("num-points",
                                                      "num points",
                                                      "The number of values in the control point array",
                                                      4, 34, 4,
                                                      PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int8_array ("control-pts",
                                                           "control pts",
                                                           "The spline control points: { cp1.x, cp1.y, cp2.x, cp2.y, ... }",
                                                           PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-curves-explicit
   */
  procedure = picman_procedure_new (curves_explicit_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-curves-explicit");
  picman_procedure_set_static_strings (procedure,
                                     "picman-curves-explicit",
                                     "Modifies the intensity curve(s) for specified drawable.",
                                     "Modifies the intensity mapping for one channel in the specified drawable. The drawable must be either grayscale or RGB, and the channel can be either an intensity component, or the value. The 'curve' parameter is an array of bytes which explicitly defines how each pixel value in the drawable will be modified. Use the 'picman-curves-spline' function to modify intensity levels with Catmull Rom splines.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("channel",
                                                  "channel",
                                                  "The channel to modify",
                                                  PICMAN_TYPE_HISTOGRAM_CHANNEL,
                                                  PICMAN_HISTOGRAM_VALUE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("num-bytes",
                                                      "num bytes",
                                                      "The number of bytes in the new curve (always 256)",
                                                      0, G_MAXINT32, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int8_array ("curve",
                                                           "curve",
                                                           "The explicit curve",
                                                           PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-color-balance
   */
  procedure = picman_procedure_new (color_balance_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-color-balance");
  picman_procedure_set_static_strings (procedure,
                                     "picman-color-balance",
                                     "Modify the color balance of the specified drawable.",
                                     "Modify the color balance of the specified drawable. There are three axis which can be modified: cyan-red, magenta-green, and yellow-blue. Negative values increase the amount of the former, positive values increase the amount of the latter. Color balance can be controlled with the 'transfer_mode' setting, which allows shadows, mid-tones, and highlights in an image to be affected differently. The 'preserve-lum' parameter, if TRUE, ensures that the luminosity of each pixel remains fixed.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("transfer-mode",
                                                  "transfer mode",
                                                  "Transfer mode",
                                                  PICMAN_TYPE_TRANSFER_MODE,
                                                  PICMAN_SHADOWS,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("preserve-lum",
                                                     "preserve lum",
                                                     "Preserve luminosity values at each pixel",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("cyan-red",
                                                    "cyan red",
                                                    "Cyan-Red color balance",
                                                    -100, 100, -100,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("magenta-green",
                                                    "magenta green",
                                                    "Magenta-Green color balance",
                                                    -100, 100, -100,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("yellow-blue",
                                                    "yellow blue",
                                                    "Yellow-Blue color balance",
                                                    -100, 100, -100,
                                                    PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-colorize
   */
  procedure = picman_procedure_new (colorize_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-colorize");
  picman_procedure_set_static_strings (procedure,
                                     "picman-colorize",
                                     "Render the drawable as a grayscale image seen through a colored glass.",
                                     "Desaturates the drawable, then tints it with the specified color. This tool is only valid on RGB color images. It will not operate on grayscale drawables.",
                                     "Sven Neumann <sven@picman.org>",
                                     "Sven Neumann",
                                     "2004",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("hue",
                                                    "hue",
                                                    "Hue in degrees",
                                                    0, 360, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("saturation",
                                                    "saturation",
                                                    "Saturation in percent",
                                                    0, 100, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("lightness",
                                                    "lightness",
                                                    "Lightness in percent",
                                                    -100, 100, -100,
                                                    PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-histogram
   */
  procedure = picman_procedure_new (histogram_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-histogram");
  picman_procedure_set_static_strings (procedure,
                                     "picman-histogram",
                                     "Returns information on the intensity histogram for the specified drawable.",
                                     "This tool makes it possible to gather information about the intensity histogram of a drawable. A channel to examine is first specified. This can be either value, red, green, or blue, depending on whether the drawable is of type color or grayscale. The drawable may not be indexed. Second, a range of intensities are specified. The 'picman-histogram' function returns statistics based on the pixels in the drawable that fall under this range of values. Mean, standard deviation, median, number of pixels, and percentile are all returned. Additionally, the total count of pixels in the image is returned. Counts of pixels are weighted by any associated alpha values and by the current selection mask. That is, pixels that lie outside an active selection mask will not be counted. Similarly, pixels with transparent alpha values will not be counted.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("channel",
                                                  "channel",
                                                  "The channel to modify",
                                                  PICMAN_TYPE_HISTOGRAM_CHANNEL,
                                                  PICMAN_HISTOGRAM_VALUE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("start-range",
                                                      "start range",
                                                      "Start of the intensity measurement range",
                                                      0, 255, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("end-range",
                                                      "end range",
                                                      "End of the intensity measurement range",
                                                      0, 255, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_double ("mean",
                                                        "mean",
                                                        "Mean intensity value",
                                                        -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_double ("std-dev",
                                                        "std dev",
                                                        "Standard deviation of intensity values",
                                                        -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_double ("median",
                                                        "median",
                                                        "Median intensity value",
                                                        -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_double ("pixels",
                                                        "pixels",
                                                        "Alpha-weighted pixel count for entire image",
                                                        -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_double ("count",
                                                        "count",
                                                        "Alpha-weighted pixel count for range",
                                                        -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_double ("percentile",
                                                        "percentile",
                                                        "Percentile that range falls under",
                                                        -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                        PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-hue-saturation
   */
  procedure = picman_procedure_new (hue_saturation_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-hue-saturation");
  picman_procedure_set_static_strings (procedure,
                                     "picman-hue-saturation",
                                     "Modify hue, lightness, and saturation in the specified drawable.",
                                     "This procedures allows the hue, lightness, and saturation in the specified drawable to be modified. The 'hue-range' parameter provides the capability to limit range of affected hues.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("hue-range",
                                                  "hue range",
                                                  "Range of affected hues",
                                                  PICMAN_TYPE_HUE_RANGE,
                                                  PICMAN_ALL_HUES,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("hue-offset",
                                                    "hue offset",
                                                    "Hue offset in degrees",
                                                    -180, 180, -180,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("lightness",
                                                    "lightness",
                                                    "Lightness modification",
                                                    -100, 100, -100,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("saturation",
                                                    "saturation",
                                                    "Saturation modification",
                                                    -100, 100, -100,
                                                    PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-threshold
   */
  procedure = picman_procedure_new (threshold_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-threshold");
  picman_procedure_set_static_strings (procedure,
                                     "picman-threshold",
                                     "Threshold the specified drawable.",
                                     "This procedures generates a threshold map of the specified drawable. All pixels between the values of 'low_threshold' and 'high_threshold' are replaced with white, and all other pixels with black.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1997",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("low-threshold",
                                                      "low threshold",
                                                      "The low threshold value",
                                                      0, 255, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("high-threshold",
                                                      "high threshold",
                                                      "The high threshold value",
                                                      0, 255, 0,
                                                      PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);
}
