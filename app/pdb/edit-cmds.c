/* PICMAN - The GNU Image Manipulation Program
 * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl. */

#include "config.h"

#include <string.h>

#include <gegl.h>

#include <gdk-pixbuf/gdk-pixbuf.h>

#include "libpicmanbase/picmanbase.h"

#include "pdb-types.h"

#include "core/picman-edit.h"
#include "core/picman.h"
#include "core/picmanchannel.h"
#include "core/picmandrawable-blend.h"
#include "core/picmandrawable-bucket-fill.h"
#include "core/picmandrawable.h"
#include "core/picmanimage-new.h"
#include "core/picmanimage.h"
#include "core/picmanlayer.h"
#include "core/picmanparamspecs.h"
#include "core/picmanprogress.h"
#include "core/picmanstrokeoptions.h"
#include "vectors/picmanvectors.h"

#include "picmanpdb.h"
#include "picmanpdb-utils.h"
#include "picmanprocedure.h"
#include "internal-procs.h"

#include "picman-intl.h"


static PicmanValueArray *
edit_cut_invoker (PicmanProcedure         *procedure,
                  Picman                  *picman,
                  PicmanContext           *context,
                  PicmanProgress          *progress,
                  const PicmanValueArray  *args,
                  GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanDrawable *drawable;
  gboolean non_empty = FALSE;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          PicmanImage *image    = picman_item_get_image (PICMAN_ITEM (drawable));
          GError    *my_error = NULL;

          non_empty = picman_edit_cut (image, drawable, context, &my_error) != NULL;

          if (! non_empty)
            {
              picman_message_literal (picman,
                                    G_OBJECT (progress), PICMAN_MESSAGE_WARNING,
                                    my_error->message);
              g_clear_error (&my_error);
            }
        }
      else
        success = FALSE;
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), non_empty);

  return return_vals;
}

static PicmanValueArray *
edit_copy_invoker (PicmanProcedure         *procedure,
                   Picman                  *picman,
                   PicmanContext           *context,
                   PicmanProgress          *progress,
                   const PicmanValueArray  *args,
                   GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanDrawable *drawable;
  gboolean non_empty = FALSE;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL, 0, error))
        {
          PicmanImage *image    = picman_item_get_image (PICMAN_ITEM (drawable));
          GError    *my_error = NULL;

          non_empty = picman_edit_copy (image, drawable, context, &my_error) != NULL;

          if (! non_empty)
            {
              picman_message_literal (picman,
                                    G_OBJECT (progress), PICMAN_MESSAGE_WARNING,
                                    my_error->message);
              g_clear_error (&my_error);
            }
        }
      else
        success = FALSE;
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), non_empty);

  return return_vals;
}

static PicmanValueArray *
edit_copy_visible_invoker (PicmanProcedure         *procedure,
                           Picman                  *picman,
                           PicmanContext           *context,
                           PicmanProgress          *progress,
                           const PicmanValueArray  *args,
                           GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanImage *image;
  gboolean non_empty = FALSE;

  image = picman_value_get_image (picman_value_array_index (args, 0), picman);

  if (success)
    {
      GError *my_error = NULL;

      non_empty = picman_edit_copy_visible (image, context, &my_error) != NULL;

      if (! non_empty)
        {
          picman_message_literal (picman,
                                G_OBJECT (progress), PICMAN_MESSAGE_WARNING,
                                my_error->message);
          g_clear_error (&my_error);
        }
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), non_empty);

  return return_vals;
}

static PicmanValueArray *
edit_paste_invoker (PicmanProcedure         *procedure,
                    Picman                  *picman,
                    PicmanContext           *context,
                    PicmanProgress          *progress,
                    const PicmanValueArray  *args,
                    GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanDrawable *drawable;
  gboolean paste_into;
  PicmanLayer *floating_sel = NULL;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  paste_into = g_value_get_boolean (picman_value_array_index (args, 1));

  if (success)
    {
      if (picman->global_buffer &&
          picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          floating_sel = picman_edit_paste (picman_item_get_image (PICMAN_ITEM (drawable)),
                                          drawable, picman->global_buffer,
                                          paste_into, -1, -1, -1, -1);

          if (! floating_sel)
            success = FALSE;
        }
      else
        success = FALSE;
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    picman_value_set_layer (picman_value_array_index (return_vals, 1), floating_sel);

  return return_vals;
}

static PicmanValueArray *
edit_paste_as_new_invoker (PicmanProcedure         *procedure,
                           Picman                  *picman,
                           PicmanContext           *context,
                           PicmanProgress          *progress,
                           const PicmanValueArray  *args,
                           GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanImage *image = NULL;

  if (picman->global_buffer)
    {
      image = picman_image_new_from_buffer (picman, NULL, picman->global_buffer);

      if (! image)
        success = FALSE;
    }
  else
    {
      image = NULL;
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    picman_value_set_image (picman_value_array_index (return_vals, 1), image);

  return return_vals;
}

static PicmanValueArray *
edit_named_cut_invoker (PicmanProcedure         *procedure,
                        Picman                  *picman,
                        PicmanContext           *context,
                        PicmanProgress          *progress,
                        const PicmanValueArray  *args,
                        GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanDrawable *drawable;
  const gchar *buffer_name;
  gchar *real_name = NULL;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  buffer_name = g_value_get_string (picman_value_array_index (args, 1));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          PicmanImage *image    = picman_item_get_image (PICMAN_ITEM (drawable));
          GError    *my_error = NULL;

          real_name = (gchar *) picman_edit_named_cut (image, buffer_name,
                                                     drawable, context, &my_error);

          if (real_name)
            {
              real_name = g_strdup (real_name);
            }
          else
            {
              picman_message_literal (picman,
                                    G_OBJECT (progress), PICMAN_MESSAGE_WARNING,
                                    my_error->message);
              g_clear_error (&my_error);
            }
        }
      else
        success = FALSE;
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_take_string (picman_value_array_index (return_vals, 1), real_name);

  return return_vals;
}

static PicmanValueArray *
edit_named_copy_invoker (PicmanProcedure         *procedure,
                         Picman                  *picman,
                         PicmanContext           *context,
                         PicmanProgress          *progress,
                         const PicmanValueArray  *args,
                         GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanDrawable *drawable;
  const gchar *buffer_name;
  gchar *real_name = NULL;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  buffer_name = g_value_get_string (picman_value_array_index (args, 1));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL, 0, error))
        {
          PicmanImage *image    = picman_item_get_image (PICMAN_ITEM (drawable));
          GError    *my_error = NULL;

          real_name = (gchar *) picman_edit_named_copy (image, buffer_name,
                                                      drawable, context, &my_error);

          if (real_name)
            {
              real_name = g_strdup (real_name);
            }
          else
            {
              picman_message_literal (picman,
                                    G_OBJECT (progress), PICMAN_MESSAGE_WARNING,
                                    my_error->message);
              g_clear_error (&my_error);
            }
        }
      else
        success = FALSE;
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_take_string (picman_value_array_index (return_vals, 1), real_name);

  return return_vals;
}

static PicmanValueArray *
edit_named_copy_visible_invoker (PicmanProcedure         *procedure,
                                 Picman                  *picman,
                                 PicmanContext           *context,
                                 PicmanProgress          *progress,
                                 const PicmanValueArray  *args,
                                 GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanImage *image;
  const gchar *buffer_name;
  gchar *real_name = NULL;

  image = picman_value_get_image (picman_value_array_index (args, 0), picman);
  buffer_name = g_value_get_string (picman_value_array_index (args, 1));

  if (success)
    {
      GError *my_error = NULL;

      real_name = (gchar *) picman_edit_named_copy_visible (image, buffer_name,
                                                          context, &my_error);

      if (real_name)
        {
          real_name = g_strdup (real_name);
        }
      else
        {
          picman_message_literal (picman,
                                G_OBJECT (progress), PICMAN_MESSAGE_WARNING,
                                my_error->message);
          g_clear_error (&my_error);
        }
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_take_string (picman_value_array_index (return_vals, 1), real_name);

  return return_vals;
}

static PicmanValueArray *
edit_named_paste_invoker (PicmanProcedure         *procedure,
                          Picman                  *picman,
                          PicmanContext           *context,
                          PicmanProgress          *progress,
                          const PicmanValueArray  *args,
                          GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanDrawable *drawable;
  const gchar *buffer_name;
  gboolean paste_into;
  PicmanLayer *floating_sel = NULL;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  buffer_name = g_value_get_string (picman_value_array_index (args, 1));
  paste_into = g_value_get_boolean (picman_value_array_index (args, 2));

  if (success)
    {
      PicmanBuffer *buffer = picman_pdb_get_buffer (picman, buffer_name, error);

      if (buffer &&
          picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          floating_sel = picman_edit_paste (picman_item_get_image (PICMAN_ITEM (drawable)),
                                          drawable, buffer,
                                          paste_into, -1, -1, -1, -1);
          if (! floating_sel)
            success = FALSE;
        }
      else
        success = FALSE;
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    picman_value_set_layer (picman_value_array_index (return_vals, 1), floating_sel);

  return return_vals;
}

static PicmanValueArray *
edit_named_paste_as_new_invoker (PicmanProcedure         *procedure,
                                 Picman                  *picman,
                                 PicmanContext           *context,
                                 PicmanProgress          *progress,
                                 const PicmanValueArray  *args,
                                 GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  const gchar *buffer_name;
  PicmanImage *image = NULL;

  buffer_name = g_value_get_string (picman_value_array_index (args, 0));

  if (success)
    {
      PicmanBuffer *buffer = picman_pdb_get_buffer (picman, buffer_name, error);

      if (buffer)
        {
          image = picman_image_new_from_buffer (picman, NULL, buffer);

          if (! image)
            success = FALSE;
        }
      else
        success = FALSE;
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    picman_value_set_image (picman_value_array_index (return_vals, 1), image);

  return return_vals;
}

static PicmanValueArray *
edit_clear_invoker (PicmanProcedure         *procedure,
                    Picman                  *picman,
                    PicmanContext           *context,
                    PicmanProgress          *progress,
                    const PicmanValueArray  *args,
                    GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          PicmanImage *image = picman_item_get_image (PICMAN_ITEM (drawable));

          success = picman_edit_clear (image, drawable, context);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
edit_fill_invoker (PicmanProcedure         *procedure,
                   Picman                  *picman,
                   PicmanContext           *context,
                   PicmanProgress          *progress,
                   const PicmanValueArray  *args,
                   GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 fill_type;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  fill_type = g_value_get_enum (picman_value_array_index (args, 1));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          PicmanImage *image = picman_item_get_image (PICMAN_ITEM (drawable));

          success = picman_edit_fill (image, drawable, context,
                                    (PicmanFillType) fill_type,
                                    PICMAN_OPACITY_OPAQUE, PICMAN_NORMAL_MODE);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
edit_bucket_fill_invoker (PicmanProcedure         *procedure,
                          Picman                  *picman,
                          PicmanContext           *context,
                          PicmanProgress          *progress,
                          const PicmanValueArray  *args,
                          GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 fill_mode;
  gint32 paint_mode;
  gdouble opacity;
  gdouble threshold;
  gboolean sample_merged;
  gdouble x;
  gdouble y;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  fill_mode = g_value_get_enum (picman_value_array_index (args, 1));
  paint_mode = g_value_get_enum (picman_value_array_index (args, 2));
  opacity = g_value_get_double (picman_value_array_index (args, 3));
  threshold = g_value_get_double (picman_value_array_index (args, 4));
  sample_merged = g_value_get_boolean (picman_value_array_index (args, 5));
  x = g_value_get_double (picman_value_array_index (args, 6));
  y = g_value_get_double (picman_value_array_index (args, 7));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          PicmanImage *image = picman_item_get_image (PICMAN_ITEM (drawable));

          if (! picman_channel_is_empty (picman_image_get_mask (image)))
            {
              PicmanFillType fill_type = PICMAN_FG_BUCKET_FILL;

              switch (fill_mode)
                {
                case PICMAN_FG_BUCKET_FILL:
                  fill_type = PICMAN_FOREGROUND_FILL;
                  break;

                case PICMAN_BG_BUCKET_FILL:
                  fill_type = PICMAN_BACKGROUND_FILL;
                  break;

                case PICMAN_PATTERN_BUCKET_FILL:
                  fill_type = PICMAN_PATTERN_FILL;
                  break;
                }

              success = picman_edit_fill (image, drawable, context, fill_type,
                                        PICMAN_OPACITY_OPAQUE, PICMAN_NORMAL_MODE);
            }
          else
            {
              success = picman_drawable_bucket_fill (drawable, context, fill_mode,
                                                   paint_mode, opacity / 100.0,
                                                   FALSE /* don't fill transparent */,
                                                   PICMAN_SELECT_CRITERION_COMPOSITE,
                                                   threshold / 255.0,
                                                   sample_merged, x, y,
                                                   error);
            }
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
edit_bucket_fill_full_invoker (PicmanProcedure         *procedure,
                               Picman                  *picman,
                               PicmanContext           *context,
                               PicmanProgress          *progress,
                               const PicmanValueArray  *args,
                               GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 fill_mode;
  gint32 paint_mode;
  gdouble opacity;
  gdouble threshold;
  gboolean sample_merged;
  gboolean fill_transparent;
  gint32 select_criterion;
  gdouble x;
  gdouble y;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  fill_mode = g_value_get_enum (picman_value_array_index (args, 1));
  paint_mode = g_value_get_enum (picman_value_array_index (args, 2));
  opacity = g_value_get_double (picman_value_array_index (args, 3));
  threshold = g_value_get_double (picman_value_array_index (args, 4));
  sample_merged = g_value_get_boolean (picman_value_array_index (args, 5));
  fill_transparent = g_value_get_boolean (picman_value_array_index (args, 6));
  select_criterion = g_value_get_enum (picman_value_array_index (args, 7));
  x = g_value_get_double (picman_value_array_index (args, 8));
  y = g_value_get_double (picman_value_array_index (args, 9));

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          PicmanImage *image = picman_item_get_image (PICMAN_ITEM (drawable));

          if (! picman_channel_is_empty (picman_image_get_mask (image)))
            {
              PicmanFillType fill_type = PICMAN_FG_BUCKET_FILL;

              switch (fill_mode)
                {
                case PICMAN_FG_BUCKET_FILL:
                  fill_type = PICMAN_FOREGROUND_FILL;
                  break;

                case PICMAN_BG_BUCKET_FILL:
                  fill_type = PICMAN_BACKGROUND_FILL;
                  break;

                case PICMAN_PATTERN_BUCKET_FILL:
                  fill_type = PICMAN_PATTERN_FILL;
                  break;
                }

              success = picman_edit_fill (image, drawable, context, fill_type,
                                        PICMAN_OPACITY_OPAQUE, PICMAN_NORMAL_MODE);
            }
          else
            {
              success = picman_drawable_bucket_fill (drawable, context, fill_mode,
                                                   paint_mode, opacity / 100.0,
                                                   fill_transparent,
                                                   select_criterion,
                                                   threshold / 255.0,
                                                   sample_merged, x, y,
                                                   error);
            }
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
edit_blend_invoker (PicmanProcedure         *procedure,
                    Picman                  *picman,
                    PicmanContext           *context,
                    PicmanProgress          *progress,
                    const PicmanValueArray  *args,
                    GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  gint32 blend_mode;
  gint32 paint_mode;
  gint32 gradient_type;
  gdouble opacity;
  gdouble offset;
  gint32 repeat;
  gboolean reverse;
  gboolean supersample;
  gint32 max_depth;
  gdouble threshold;
  gboolean dither;
  gdouble x1;
  gdouble y1;
  gdouble x2;
  gdouble y2;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  blend_mode = g_value_get_enum (picman_value_array_index (args, 1));
  paint_mode = g_value_get_enum (picman_value_array_index (args, 2));
  gradient_type = g_value_get_enum (picman_value_array_index (args, 3));
  opacity = g_value_get_double (picman_value_array_index (args, 4));
  offset = g_value_get_double (picman_value_array_index (args, 5));
  repeat = g_value_get_enum (picman_value_array_index (args, 6));
  reverse = g_value_get_boolean (picman_value_array_index (args, 7));
  supersample = g_value_get_boolean (picman_value_array_index (args, 8));
  max_depth = g_value_get_int (picman_value_array_index (args, 9));
  threshold = g_value_get_double (picman_value_array_index (args, 10));
  dither = g_value_get_boolean (picman_value_array_index (args, 11));
  x1 = g_value_get_double (picman_value_array_index (args, 12));
  y1 = g_value_get_double (picman_value_array_index (args, 13));
  x2 = g_value_get_double (picman_value_array_index (args, 14));
  y2 = g_value_get_double (picman_value_array_index (args, 15));

  if (success)
    {
      success = (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                            PICMAN_PDB_ITEM_CONTENT, error) &&
                 picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error));

      if (success && supersample)
        {
          if (max_depth < 1 || max_depth > 9)
            success = FALSE;

          if (threshold < 0.0 || threshold > 4.0)
            success = FALSE;
        }

      if (success)
        {
          if (progress)
            picman_progress_start (progress, _("Blending"), FALSE);

          picman_drawable_blend (drawable,
                               context,
                               blend_mode,
                               paint_mode,
                               gradient_type,
                               opacity / 100.0,
                               offset, repeat, reverse,
                               supersample, max_depth,
                               threshold, dither,
                               x1, y1, x2, y2,
                               progress);

          if (progress)
            picman_progress_end (progress);
        }
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
edit_stroke_invoker (PicmanProcedure         *procedure,
                     Picman                  *picman,
                     PicmanContext           *context,
                     PicmanProgress          *progress,
                     const PicmanValueArray  *args,
                     GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error))
        {
          PicmanImage         *image   = picman_item_get_image (PICMAN_ITEM (drawable));
          PicmanStrokeOptions *options = picman_stroke_options_new (picman, context, TRUE);

          g_object_set (options,
                        "method", PICMAN_STROKE_METHOD_PAINT_CORE,
                        NULL);

          success = picman_item_stroke (PICMAN_ITEM (picman_image_get_mask (image)),
                                      drawable, context, options, TRUE, TRUE,
                                      progress, error);

          g_object_unref (options);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
edit_stroke_vectors_invoker (PicmanProcedure         *procedure,
                             Picman                  *picman,
                             PicmanContext           *context,
                             PicmanProgress          *progress,
                             const PicmanValueArray  *args,
                             GError               **error)
{
  gboolean success = TRUE;
  PicmanDrawable *drawable;
  PicmanVectors *vectors;

  drawable = picman_value_get_drawable (picman_value_array_index (args, 0), picman);
  vectors = picman_value_get_vectors (picman_value_array_index (args, 1), picman);

  if (success)
    {
      if (picman_pdb_item_is_attached (PICMAN_ITEM (drawable), NULL,
                                     PICMAN_PDB_ITEM_CONTENT, error) &&
          picman_pdb_item_is_not_group (PICMAN_ITEM (drawable), error) &&
          picman_pdb_item_is_attached (PICMAN_ITEM (vectors),
                                     picman_item_get_image (PICMAN_ITEM (drawable)),
                                     0, error))
        {
          PicmanStrokeOptions *options = picman_stroke_options_new (picman, context, TRUE);

          g_object_set (options,
                        "method", PICMAN_STROKE_METHOD_PAINT_CORE,
                        NULL);

          success = picman_item_stroke (PICMAN_ITEM (vectors),
                                      drawable, context, options, TRUE, TRUE,
                                      progress, error);

          g_object_unref (options);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

void
register_edit_procs (PicmanPDB *pdb)
{
  PicmanProcedure *procedure;

  /*
   * picman-edit-cut
   */
  procedure = picman_procedure_new (edit_cut_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-cut");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-cut",
                                     "Cut from the specified drawable.",
                                     "If there is a selection in the image, then the area specified by the selection is cut from the specified drawable and placed in an internal PICMAN edit buffer. It can subsequently be retrieved using the 'picman-edit-paste' command. If there is no selection, then the specified drawable will be removed and its contents stored in the internal PICMAN edit buffer. This procedure will fail if the selected area lies completely outside the bounds of the current drawable and there is nothing to copy from.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable to cut from",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("non-empty",
                                                         "non empty",
                                                         "TRUE if the cut was successful, FALSE if there was nothing to copy from",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-copy
   */
  procedure = picman_procedure_new (edit_copy_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-copy");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-copy",
                                     "Copy from the specified drawable.",
                                     "If there is a selection in the image, then the area specified by the selection is copied from the specified drawable and placed in an internal PICMAN edit buffer. It can subsequently be retrieved using the 'picman-edit-paste' command. If there is no selection, then the specified drawable's contents will be stored in the internal PICMAN edit buffer. This procedure will fail if the selected area lies completely outside the bounds of the current drawable and there is nothing to copy from.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable to copy from",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("non-empty",
                                                         "non empty",
                                                         "TRUE if the cut was successful, FALSE if there was nothing to copy from",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-copy-visible
   */
  procedure = picman_procedure_new (edit_copy_visible_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-copy-visible");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-copy-visible",
                                     "Copy from the projection.",
                                     "If there is a selection in the image, then the area specified by the selection is copied from the projection and placed in an internal PICMAN edit buffer. It can subsequently be retrieved using the 'picman-edit-paste' command. If there is no selection, then the projection's contents will be stored in the internal PICMAN edit buffer.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2004",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "The image to copy from",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("non-empty",
                                                         "non empty",
                                                         "TRUE if the copy was successful",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-paste
   */
  procedure = picman_procedure_new (edit_paste_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-paste");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-paste",
                                     "Paste buffer to the specified drawable.",
                                     "This procedure pastes a copy of the internal PICMAN edit buffer to the specified drawable. The PICMAN edit buffer will be empty unless a call was previously made to either 'picman-edit-cut' or 'picman-edit-copy'. The \"paste_into\" option specifies whether to clear the current image selection, or to paste the buffer \"behind\" the selection. This allows the selection to act as a mask for the pasted buffer. Anywhere that the selection mask is non-zero, the pasted buffer will show through. The pasted buffer will be a new layer in the image which is designated as the image floating selection. If the image has a floating selection at the time of pasting, the old floating selection will be anchored to it's drawable before the new floating selection is added. This procedure returns the new floating layer. The resulting floating selection will already be attached to the specified drawable, and a subsequent call to floating_sel_attach is not needed.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable to paste to",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("paste-into",
                                                     "paste into",
                                                     "Clear selection, or paste behind it?",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_layer_id ("floating-sel",
                                                             "floating sel",
                                                             "The new floating selection",
                                                             pdb->picman, FALSE,
                                                             PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-paste-as-new
   */
  procedure = picman_procedure_new (edit_paste_as_new_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-paste-as-new");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-paste-as-new",
                                     "Paste buffer to a new image.",
                                     "This procedure pastes a copy of the internal PICMAN edit buffer to a new image. The PICMAN edit buffer will be empty unless a call was previously made to either 'picman-edit-cut' or 'picman-edit-copy'. This procedure returns the new image or -1 if the edit buffer was empty.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2005",
                                     NULL);
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_image_id ("image",
                                                             "image",
                                                             "The new image",
                                                             pdb->picman, FALSE,
                                                             PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-named-cut
   */
  procedure = picman_procedure_new (edit_named_cut_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-named-cut");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-named-cut",
                                     "Cut into a named buffer.",
                                     "This procedure works like 'picman-edit-cut', but additionally stores the cut buffer into a named buffer that will stay available for later pasting, regardless of any intermediate copy or cut operations.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2005",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable to cut from",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("buffer-name",
                                                       "buffer name",
                                                       "The name of the buffer to create",
                                                       FALSE, FALSE, TRUE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_string ("real-name",
                                                           "real name",
                                                           "The real name given to the buffer, or NULL if the cut failed",
                                                           FALSE, FALSE, FALSE,
                                                           NULL,
                                                           PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-named-copy
   */
  procedure = picman_procedure_new (edit_named_copy_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-named-copy");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-named-copy",
                                     "Copy into a named buffer.",
                                     "This procedure works like 'picman-edit-copy', but additionally stores the copied buffer into a named buffer that will stay available for later pasting, regardless of any intermediate copy or cut operations.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2005",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable to copy from",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("buffer-name",
                                                       "buffer name",
                                                       "The name of the buffer to create",
                                                       FALSE, FALSE, TRUE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_string ("real-name",
                                                           "real name",
                                                           "The real name given to the buffer, or NULL if the copy failed",
                                                           FALSE, FALSE, FALSE,
                                                           NULL,
                                                           PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-named-copy-visible
   */
  procedure = picman_procedure_new (edit_named_copy_visible_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-named-copy-visible");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-named-copy-visible",
                                     "Copy from the projection into a named buffer.",
                                     "This procedure works like 'picman-edit-copy-visible', but additionally stores the copied buffer into a named buffer that will stay available for later pasting, regardless of any intermediate copy or cut operations.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2005",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_image_id ("image",
                                                         "image",
                                                         "The image to copy from",
                                                         pdb->picman, FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("buffer-name",
                                                       "buffer name",
                                                       "The name of the buffer to create",
                                                       FALSE, FALSE, TRUE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_string ("real-name",
                                                           "real name",
                                                           "The real name given to the buffer, or NULL if the copy failed",
                                                           FALSE, FALSE, FALSE,
                                                           NULL,
                                                           PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-named-paste
   */
  procedure = picman_procedure_new (edit_named_paste_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-named-paste");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-named-paste",
                                     "Paste named buffer to the specified drawable.",
                                     "This procedure works like 'picman-edit-paste' but pastes a named buffer instead of the global buffer.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2005",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable to paste to",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("buffer-name",
                                                       "buffer name",
                                                       "The name of the buffer to paste",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("paste-into",
                                                     "paste into",
                                                     "Clear selection, or paste behind it?",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_layer_id ("floating-sel",
                                                             "floating sel",
                                                             "The new floating selection",
                                                             pdb->picman, FALSE,
                                                             PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-named-paste-as-new
   */
  procedure = picman_procedure_new (edit_named_paste_as_new_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-named-paste-as-new");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-named-paste-as-new",
                                     "Paste named buffer to a new image.",
                                     "This procedure works like 'picman-edit-paste-as-new' but pastes a named buffer instead of the global buffer.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2005",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("buffer-name",
                                                       "buffer name",
                                                       "The name of the buffer to paste",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_image_id ("image",
                                                             "image",
                                                             "The new image",
                                                             pdb->picman, FALSE,
                                                             PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-clear
   */
  procedure = picman_procedure_new (edit_clear_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-clear");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-clear",
                                     "Clear selected area of drawable.",
                                     "This procedure clears the specified drawable. If the drawable has an alpha channel, the cleared pixels will become transparent. If the drawable does not have an alpha channel, cleared pixels will be set to the background color. This procedure only affects regions within a selection if there is a selection active.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable to clear from",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-fill
   */
  procedure = picman_procedure_new (edit_fill_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-fill");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-fill",
                                     "Fill selected area of drawable.",
                                     "This procedure fills the specified drawable with the fill mode. If the fill mode is foreground, the current foreground color is used. If the fill mode is background, the current background color is used. Other fill modes should not be used. This procedure only affects regions within a selection if there is a selection active. If you want to fill the whole drawable, regardless of the selection, use 'picman-drawable-fill'.",
                                     "Spencer Kimball & Peter Mattis & Raphael Quinet",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-2000",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable to fill to",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("fill-type",
                                                  "fill type",
                                                  "The type of fill",
                                                  PICMAN_TYPE_FILL_TYPE,
                                                  PICMAN_FOREGROUND_FILL,
                                                  PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-bucket-fill
   */
  procedure = picman_procedure_new (edit_bucket_fill_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-bucket-fill");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-bucket-fill",
                                     "Fill the area specified either by the current selection if there is one, or by a seed fill starting at the specified coordinates.",
                                     "This tool requires information on the paint application mode, and the fill mode, which can either be in the foreground color, or in the currently active pattern. If there is no selection, a seed fill is executed at the specified coordinates and extends outward in keeping with the threshold parameter. If there is a selection in the target image, the threshold, sample merged, x, and y arguments are unused. If the sample_merged parameter is TRUE, the data of the composite image will be used instead of that for the specified drawable. This is equivalent to sampling for colors after merging all visible layers. In the case of merged sampling, the x and y coordinates are relative to the image's origin; otherwise, they are relative to the drawable's origin.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The affected drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("fill-mode",
                                                  "fill mode",
                                                  "The type of fill",
                                                  PICMAN_TYPE_BUCKET_FILL_MODE,
                                                  PICMAN_FG_BUCKET_FILL,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("paint-mode",
                                                  "paint mode",
                                                  "The paint application mode",
                                                  PICMAN_TYPE_LAYER_MODE_EFFECTS,
                                                  PICMAN_NORMAL_MODE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("opacity",
                                                    "opacity",
                                                    "The opacity of the final bucket fill",
                                                    0, 100, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("threshold",
                                                    "threshold",
                                                    "The threshold determines how extensive the seed fill will be. It's value is specified in terms of intensity levels. This parameter is only valid when there is no selection in the specified image.",
                                                    0, 255, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("sample-merged",
                                                     "sample merged",
                                                     "Use the composite image, not the drawable",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("x",
                                                    "x",
                                                    "The x coordinate of this bucket fill's application. This parameter is only valid when there is no selection in the specified image.",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("y",
                                                    "y",
                                                    "The y coordinate of this bucket fill's application. This parameter is only valid when there is no selection in the specified image.",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-bucket-fill-full
   */
  procedure = picman_procedure_new (edit_bucket_fill_full_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-bucket-fill-full");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-bucket-fill-full",
                                     "Fill the area specified either by the current selection if there is one, or by a seed fill starting at the specified coordinates.",
                                     "This tool requires information on the paint application mode, and the fill mode, which can either be in the foreground color, or in the currently active pattern. If there is no selection, a seed fill is executed at the specified coordinates and extends outward in keeping with the threshold parameter. If there is a selection in the target image, the threshold, sample merged, x, and y arguments are unused. If the sample_merged parameter is TRUE, the data of the composite image will be used instead of that for the specified drawable. This is equivalent to sampling for colors after merging all visible layers. In the case of merged sampling, the x and y coordinates are relative to the image's origin; otherwise, they are relative to the drawable's origin.",
                                     "David Gowers",
                                     "David Gowers",
                                     "2006",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The affected drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("fill-mode",
                                                  "fill mode",
                                                  "The type of fill",
                                                  PICMAN_TYPE_BUCKET_FILL_MODE,
                                                  PICMAN_FG_BUCKET_FILL,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("paint-mode",
                                                  "paint mode",
                                                  "The paint application mode",
                                                  PICMAN_TYPE_LAYER_MODE_EFFECTS,
                                                  PICMAN_NORMAL_MODE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("opacity",
                                                    "opacity",
                                                    "The opacity of the final bucket fill",
                                                    0, 100, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("threshold",
                                                    "threshold",
                                                    "The threshold determines how extensive the seed fill will be. It's value is specified in terms of intensity levels. This parameter is only valid when there is no selection in the specified image.",
                                                    0, 255, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("sample-merged",
                                                     "sample merged",
                                                     "Use the composite image, not the drawable",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("fill-transparent",
                                                     "fill transparent",
                                                     "Whether to consider transparent pixels for filling. If TRUE, transparency is considered as a unique fillable color.",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("select-criterion",
                                                  "select criterion",
                                                  "The criterion used to determine color similarity. SELECT_CRITERION_COMPOSITE is the standard choice.",
                                                  PICMAN_TYPE_SELECT_CRITERION,
                                                  PICMAN_SELECT_CRITERION_COMPOSITE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("x",
                                                    "x",
                                                    "The x coordinate of this bucket fill's application. This parameter is only valid when there is no selection in the specified image.",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("y",
                                                    "y",
                                                    "The y coordinate of this bucket fill's application. This parameter is only valid when there is no selection in the specified image.",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-blend
   */
  procedure = picman_procedure_new (edit_blend_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-blend");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-blend",
                                     "Blend between the starting and ending coordinates with the specified blend mode and gradient type.",
                                     "This tool requires information on the paint application mode, the blend mode, and the gradient type. It creates the specified variety of blend using the starting and ending coordinates as defined for each gradient type.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The affected drawable",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("blend-mode",
                                                  "blend mode",
                                                  "The type of blend",
                                                  PICMAN_TYPE_BLEND_MODE,
                                                  PICMAN_FG_BG_RGB_MODE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("paint-mode",
                                                  "paint mode",
                                                  "The paint application mode",
                                                  PICMAN_TYPE_LAYER_MODE_EFFECTS,
                                                  PICMAN_NORMAL_MODE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("gradient-type",
                                                  "gradient type",
                                                  "The type of gradient",
                                                  PICMAN_TYPE_GRADIENT_TYPE,
                                                  PICMAN_GRADIENT_LINEAR,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("opacity",
                                                    "opacity",
                                                    "The opacity of the final blend",
                                                    0, 100, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("offset",
                                                    "offset",
                                                    "Offset relates to the starting and ending coordinates specified for the blend. This parameter is mode dependent.",
                                                    0, G_MAXDOUBLE, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_enum ("repeat",
                                                  "repeat",
                                                  "Repeat mode",
                                                  PICMAN_TYPE_REPEAT_MODE,
                                                  PICMAN_REPEAT_NONE,
                                                  PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("reverse",
                                                     "reverse",
                                                     "Use the reverse gradient",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("supersample",
                                                     "supersample",
                                                     "Do adaptive supersampling",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_int32 ("max-depth",
                                                      "max depth",
                                                      "Maximum recursion levels for supersampling",
                                                      1, 9, 1,
                                                      PICMAN_PARAM_READWRITE | PICMAN_PARAM_NO_VALIDATE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("threshold",
                                                    "threshold",
                                                    "Supersampling threshold",
                                                    0, 4, 0,
                                                    PICMAN_PARAM_READWRITE | PICMAN_PARAM_NO_VALIDATE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("dither",
                                                     "dither",
                                                     "Use dithering to reduce banding",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("x1",
                                                    "x1",
                                                    "The x coordinate of this blend's starting point",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("y1",
                                                    "y1",
                                                    "The y coordinate of this blend's starting point",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("x2",
                                                    "x2",
                                                    "The x coordinate of this blend's ending point",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_double ("y2",
                                                    "y2",
                                                    "The y coordinate of this blend's ending point",
                                                    -G_MAXDOUBLE, G_MAXDOUBLE, 0,
                                                    PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-stroke
   */
  procedure = picman_procedure_new (edit_stroke_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-stroke");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-stroke",
                                     "Stroke the current selection",
                                     "This procedure strokes the current selection, painting along the selection boundary with the active brush and foreground color. The paint is applied to the specified drawable regardless of the active selection.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable to stroke to",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-edit-stroke-vectors
   */
  procedure = picman_procedure_new (edit_stroke_vectors_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-edit-stroke-vectors");
  picman_procedure_set_static_strings (procedure,
                                     "picman-edit-stroke-vectors",
                                     "Stroke the specified vectors object",
                                     "This procedure strokes the specified vectors object, painting along the path with the active brush and foreground color.",
                                     "Simon Budig",
                                     "Simon Budig",
                                     "2006",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_drawable_id ("drawable",
                                                            "drawable",
                                                            "The drawable to stroke to",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_vectors_id ("vectors",
                                                           "vectors",
                                                           "The vectors object",
                                                           pdb->picman, FALSE,
                                                           PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);
}
