/* PICMAN - The GNU Image Manipulation Program
 * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* NOTE: This file is auto-generated by pdbgen.pl. */

#include "config.h"

#include <gegl.h>

#include <gdk-pixbuf/gdk-pixbuf.h>

#include "libpicmanbase/picmanbase.h"

#include "libpicmanbase/picmanbase.h"

#include "pdb-types.h"

#include "core/picmanimage.h"
#include "core/picmanitem.h"
#include "core/picmanlayermask.h"
#include "core/picmanlist.h"
#include "core/picmanparamspecs.h"
#include "core/picmanselection.h"
#include "text/picmantextlayer.h"
#include "vectors/picmanvectors.h"

#include "picmanpdb.h"
#include "picmanpdb-utils.h"
#include "picmanpdbcontext.h"
#include "picmanprocedure.h"
#include "internal-procs.h"

#include "picman-intl.h"


static PicmanValueArray *
item_is_valid_invoker (PicmanProcedure         *procedure,
                       Picman                  *picman,
                       PicmanContext           *context,
                       PicmanProgress          *progress,
                       const PicmanValueArray  *args,
                       GError               **error)
{
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean valid = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  valid = (PICMAN_IS_ITEM (item) &&
           ! picman_item_is_removed (PICMAN_ITEM (item)));

  return_vals = picman_procedure_get_return_values (procedure, TRUE, NULL);
  g_value_set_boolean (picman_value_array_index (return_vals, 1), valid);

  return return_vals;
}

static PicmanValueArray *
item_get_image_invoker (PicmanProcedure         *procedure,
                        Picman                  *picman,
                        PicmanContext           *context,
                        PicmanProgress          *progress,
                        const PicmanValueArray  *args,
                        GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  PicmanImage *image = NULL;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      image = picman_item_get_image (PICMAN_ITEM (item));
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    picman_value_set_image (picman_value_array_index (return_vals, 1), image);

  return return_vals;
}

static PicmanValueArray *
item_delete_invoker (PicmanProcedure         *procedure,
                     Picman                  *picman,
                     PicmanContext           *context,
                     PicmanProgress          *progress,
                     const PicmanValueArray  *args,
                     GError               **error)
{
  gboolean success = TRUE;
  PicmanItem *item;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      if (g_object_is_floating (item))
        {
          g_object_ref_sink (item);
          g_object_unref (item);
        }
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
item_is_drawable_invoker (PicmanProcedure         *procedure,
                          Picman                  *picman,
                          PicmanContext           *context,
                          PicmanProgress          *progress,
                          const PicmanValueArray  *args,
                          GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean drawable = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      drawable = PICMAN_IS_DRAWABLE (item);
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), drawable);

  return return_vals;
}

static PicmanValueArray *
item_is_layer_invoker (PicmanProcedure         *procedure,
                       Picman                  *picman,
                       PicmanContext           *context,
                       PicmanProgress          *progress,
                       const PicmanValueArray  *args,
                       GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean layer = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      layer = PICMAN_IS_LAYER (item);
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), layer);

  return return_vals;
}

static PicmanValueArray *
item_is_text_layer_invoker (PicmanProcedure         *procedure,
                            Picman                  *picman,
                            PicmanContext           *context,
                            PicmanProgress          *progress,
                            const PicmanValueArray  *args,
                            GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean text_layer = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      text_layer = picman_item_is_text_layer (item);
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), text_layer);

  return return_vals;
}

static PicmanValueArray *
item_is_channel_invoker (PicmanProcedure         *procedure,
                         Picman                  *picman,
                         PicmanContext           *context,
                         PicmanProgress          *progress,
                         const PicmanValueArray  *args,
                         GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean channel = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      channel = PICMAN_IS_CHANNEL (item);
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), channel);

  return return_vals;
}

static PicmanValueArray *
item_is_layer_mask_invoker (PicmanProcedure         *procedure,
                            Picman                  *picman,
                            PicmanContext           *context,
                            PicmanProgress          *progress,
                            const PicmanValueArray  *args,
                            GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean layer_mask = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      layer_mask = PICMAN_IS_LAYER_MASK (item);
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), layer_mask);

  return return_vals;
}

static PicmanValueArray *
item_is_selection_invoker (PicmanProcedure         *procedure,
                           Picman                  *picman,
                           PicmanContext           *context,
                           PicmanProgress          *progress,
                           const PicmanValueArray  *args,
                           GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean selection = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      selection = PICMAN_IS_SELECTION (item);
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), selection);

  return return_vals;
}

static PicmanValueArray *
item_is_vectors_invoker (PicmanProcedure         *procedure,
                         Picman                  *picman,
                         PicmanContext           *context,
                         PicmanProgress          *progress,
                         const PicmanValueArray  *args,
                         GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean vectors = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      vectors = PICMAN_IS_VECTORS (item);
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), vectors);

  return return_vals;
}

static PicmanValueArray *
item_is_group_invoker (PicmanProcedure         *procedure,
                       Picman                  *picman,
                       PicmanContext           *context,
                       PicmanProgress          *progress,
                       const PicmanValueArray  *args,
                       GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean group = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      group = (picman_viewable_get_children (PICMAN_VIEWABLE (item)) != NULL);
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), group);

  return return_vals;
}

static PicmanValueArray *
item_get_parent_invoker (PicmanProcedure         *procedure,
                         Picman                  *picman,
                         PicmanContext           *context,
                         PicmanProgress          *progress,
                         const PicmanValueArray  *args,
                         GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  PicmanItem *parent = NULL;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      parent = picman_item_get_parent (item);
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    picman_value_set_item (picman_value_array_index (return_vals, 1), parent);

  return return_vals;
}

static PicmanValueArray *
item_get_children_invoker (PicmanProcedure         *procedure,
                           Picman                  *picman,
                           PicmanContext           *context,
                           PicmanProgress          *progress,
                           const PicmanValueArray  *args,
                           GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gint32 num_children = 0;
  gint32 *child_ids = NULL;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      PicmanContainer *children = picman_viewable_get_children (PICMAN_VIEWABLE (item));

      if (children)
        {
          num_children = picman_container_get_n_children (children);

          if (num_children)
            {
              GList *list;
              gint   i;

              child_ids = g_new (gint32, num_children);

              for (list = PICMAN_LIST (children)->list, i = 0;
                   list;
                   list = g_list_next (list), i++)
                {
                  child_ids[i] = picman_item_get_ID (PICMAN_ITEM (list->data));
                }
            }
        }
      else
        success = FALSE;

    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    {
      g_value_set_int (picman_value_array_index (return_vals, 1), num_children);
      picman_value_take_int32array (picman_value_array_index (return_vals, 2), child_ids, num_children);
    }

  return return_vals;
}

static PicmanValueArray *
item_get_name_invoker (PicmanProcedure         *procedure,
                       Picman                  *picman,
                       PicmanContext           *context,
                       PicmanProgress          *progress,
                       const PicmanValueArray  *args,
                       GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gchar *name = NULL;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      name = g_strdup (picman_object_get_name (item));
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_take_string (picman_value_array_index (return_vals, 1), name);

  return return_vals;
}

static PicmanValueArray *
item_set_name_invoker (PicmanProcedure         *procedure,
                       Picman                  *picman,
                       PicmanContext           *context,
                       PicmanProgress          *progress,
                       const PicmanValueArray  *args,
                       GError               **error)
{
  gboolean success = TRUE;
  PicmanItem *item;
  const gchar *name;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);
  name = g_value_get_string (picman_value_array_index (args, 1));

  if (success)
    {
      success = picman_item_rename (PICMAN_ITEM (item), name, error);
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
item_get_visible_invoker (PicmanProcedure         *procedure,
                          Picman                  *picman,
                          PicmanContext           *context,
                          PicmanProgress          *progress,
                          const PicmanValueArray  *args,
                          GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean visible = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      visible = picman_item_get_visible (PICMAN_ITEM (item));
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), visible);

  return return_vals;
}

static PicmanValueArray *
item_set_visible_invoker (PicmanProcedure         *procedure,
                          Picman                  *picman,
                          PicmanContext           *context,
                          PicmanProgress          *progress,
                          const PicmanValueArray  *args,
                          GError               **error)
{
  gboolean success = TRUE;
  PicmanItem *item;
  gboolean visible;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);
  visible = g_value_get_boolean (picman_value_array_index (args, 1));

  if (success)
    {
      picman_item_set_visible (PICMAN_ITEM (item), visible, TRUE);
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
item_get_linked_invoker (PicmanProcedure         *procedure,
                         Picman                  *picman,
                         PicmanContext           *context,
                         PicmanProgress          *progress,
                         const PicmanValueArray  *args,
                         GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean linked = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      linked = picman_item_get_linked (PICMAN_ITEM (item));
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), linked);

  return return_vals;
}

static PicmanValueArray *
item_set_linked_invoker (PicmanProcedure         *procedure,
                         Picman                  *picman,
                         PicmanContext           *context,
                         PicmanProgress          *progress,
                         const PicmanValueArray  *args,
                         GError               **error)
{
  gboolean success = TRUE;
  PicmanItem *item;
  gboolean linked;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);
  linked = g_value_get_boolean (picman_value_array_index (args, 1));

  if (success)
    {
      picman_item_set_linked (PICMAN_ITEM (item), linked, TRUE);
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
item_get_lock_content_invoker (PicmanProcedure         *procedure,
                               Picman                  *picman,
                               PicmanContext           *context,
                               PicmanProgress          *progress,
                               const PicmanValueArray  *args,
                               GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean lock_content = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      lock_content = picman_item_get_lock_content (PICMAN_ITEM (item));
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), lock_content);

  return return_vals;
}

static PicmanValueArray *
item_set_lock_content_invoker (PicmanProcedure         *procedure,
                               Picman                  *picman,
                               PicmanContext           *context,
                               PicmanProgress          *progress,
                               const PicmanValueArray  *args,
                               GError               **error)
{
  gboolean success = TRUE;
  PicmanItem *item;
  gboolean lock_content;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);
  lock_content = g_value_get_boolean (picman_value_array_index (args, 1));

  if (success)
    {
      if (picman_item_can_lock_content (PICMAN_ITEM (item)))
        picman_item_set_lock_content (PICMAN_ITEM (item), lock_content, TRUE);
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
item_get_lock_position_invoker (PicmanProcedure         *procedure,
                                Picman                  *picman,
                                PicmanContext           *context,
                                PicmanProgress          *progress,
                                const PicmanValueArray  *args,
                                GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gboolean lock_position = FALSE;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      lock_position = picman_item_get_lock_position (PICMAN_ITEM (item));
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_boolean (picman_value_array_index (return_vals, 1), lock_position);

  return return_vals;
}

static PicmanValueArray *
item_set_lock_position_invoker (PicmanProcedure         *procedure,
                                Picman                  *picman,
                                PicmanContext           *context,
                                PicmanProgress          *progress,
                                const PicmanValueArray  *args,
                                GError               **error)
{
  gboolean success = TRUE;
  PicmanItem *item;
  gboolean lock_position;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);
  lock_position = g_value_get_boolean (picman_value_array_index (args, 1));

  if (success)
    {
      if (picman_item_can_lock_position (PICMAN_ITEM (item)))
        picman_item_set_lock_position (PICMAN_ITEM (item), lock_position, TRUE);
      else
        success = FALSE;
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
item_get_tattoo_invoker (PicmanProcedure         *procedure,
                         Picman                  *picman,
                         PicmanContext           *context,
                         PicmanProgress          *progress,
                         const PicmanValueArray  *args,
                         GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gint32 tattoo = 0;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      tattoo = picman_item_get_tattoo (PICMAN_ITEM (item));
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_set_uint (picman_value_array_index (return_vals, 1), tattoo);

  return return_vals;
}

static PicmanValueArray *
item_set_tattoo_invoker (PicmanProcedure         *procedure,
                         Picman                  *picman,
                         PicmanContext           *context,
                         PicmanProgress          *progress,
                         const PicmanValueArray  *args,
                         GError               **error)
{
  gboolean success = TRUE;
  PicmanItem *item;
  gint32 tattoo;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);
  tattoo = g_value_get_uint (picman_value_array_index (args, 1));

  if (success)
    {
      picman_item_set_tattoo (PICMAN_ITEM (item), tattoo);
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
item_attach_parasite_invoker (PicmanProcedure         *procedure,
                              Picman                  *picman,
                              PicmanContext           *context,
                              PicmanProgress          *progress,
                              const PicmanValueArray  *args,
                              GError               **error)
{
  gboolean success = TRUE;
  PicmanItem *item;
  const PicmanParasite *parasite;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);
  parasite = g_value_get_boxed (picman_value_array_index (args, 1));

  if (success)
    {
      picman_item_parasite_attach (item, parasite, TRUE);
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
item_detach_parasite_invoker (PicmanProcedure         *procedure,
                              Picman                  *picman,
                              PicmanContext           *context,
                              PicmanProgress          *progress,
                              const PicmanValueArray  *args,
                              GError               **error)
{
  gboolean success = TRUE;
  PicmanItem *item;
  const gchar *name;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);
  name = g_value_get_string (picman_value_array_index (args, 1));

  if (success)
    {
      picman_item_parasite_detach (item, name, TRUE);
    }

  return picman_procedure_get_return_values (procedure, success,
                                           error ? *error : NULL);
}

static PicmanValueArray *
item_get_parasite_invoker (PicmanProcedure         *procedure,
                           Picman                  *picman,
                           PicmanContext           *context,
                           PicmanProgress          *progress,
                           const PicmanValueArray  *args,
                           GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  const gchar *name;
  PicmanParasite *parasite = NULL;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);
  name = g_value_get_string (picman_value_array_index (args, 1));

  if (success)
    {
      parasite = picman_parasite_copy (picman_item_parasite_find (item, name));

      if (! parasite)
        success = FALSE;
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    g_value_take_boxed (picman_value_array_index (return_vals, 1), parasite);

  return return_vals;
}

static PicmanValueArray *
item_get_parasite_list_invoker (PicmanProcedure         *procedure,
                                Picman                  *picman,
                                PicmanContext           *context,
                                PicmanProgress          *progress,
                                const PicmanValueArray  *args,
                                GError               **error)
{
  gboolean success = TRUE;
  PicmanValueArray *return_vals;
  PicmanItem *item;
  gint32 num_parasites = 0;
  gchar **parasites = NULL;

  item = picman_value_get_item (picman_value_array_index (args, 0), picman);

  if (success)
    {
      parasites = picman_item_parasite_list (item, &num_parasites);
    }

  return_vals = picman_procedure_get_return_values (procedure, success,
                                                  error ? *error : NULL);

  if (success)
    {
      g_value_set_int (picman_value_array_index (return_vals, 1), num_parasites);
      picman_value_take_stringarray (picman_value_array_index (return_vals, 2), parasites, num_parasites);
    }

  return return_vals;
}

void
register_item_procs (PicmanPDB *pdb)
{
  PicmanProcedure *procedure;

  /*
   * picman-item-is-valid
   */
  procedure = picman_procedure_new (item_is_valid_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-is-valid");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-is-valid",
                                     "Returns TRUE if the item is valid.",
                                     "This procedure checks if the given item ID is valid and refers to an existing item.",
                                     "Sven Neumann <sven@picman.org>",
                                     "Sven Neumann",
                                     "2007",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item to check",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE | PICMAN_PARAM_NO_VALIDATE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("valid",
                                                         "valid",
                                                         "Whether the item ID is valid",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-get-image
   */
  procedure = picman_procedure_new (item_get_image_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-get-image");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-get-image",
                                     "Returns the item's image.",
                                     "This procedure returns the item's image.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_image_id ("image",
                                                             "image",
                                                             "The item's image",
                                                             pdb->picman, FALSE,
                                                             PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-delete
   */
  procedure = picman_procedure_new (item_delete_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-delete");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-delete",
                                     "Delete a item.",
                                     "This procedure deletes the specified item. This must not be done if the image containing this item was already deleted or if the item was already removed from the image. The only case in which this procedure is useful is if you want to get rid of a item which has not yet been added to an image.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item to delete",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-is-drawable
   */
  procedure = picman_procedure_new (item_is_drawable_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-is-drawable");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-is-drawable",
                                     "Returns whether the item is a drawable.",
                                     "This procedure returns TRUE if the specified item is a drawable.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("drawable",
                                                         "drawable",
                                                         "TRUE if the item is a drawable, FALSE otherwise",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-is-layer
   */
  procedure = picman_procedure_new (item_is_layer_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-is-layer");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-is-layer",
                                     "Returns whether the item is a layer.",
                                     "This procedure returns TRUE if the specified item is a layer.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("layer",
                                                         "layer",
                                                         "TRUE if the item is a layer, FALSE otherwise",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-is-text-layer
   */
  procedure = picman_procedure_new (item_is_text_layer_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-is-text-layer");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-is-text-layer",
                                     "Returns whether the item is a text layer.",
                                     "This procedure returns TRUE if the specified item is a text layer.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2010",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("text-layer",
                                                         "text layer",
                                                         "TRUE if the item is a text layer, FALSE otherwise.",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-is-channel
   */
  procedure = picman_procedure_new (item_is_channel_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-is-channel");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-is-channel",
                                     "Returns whether the item is a channel.",
                                     "This procedure returns TRUE if the specified item is a channel.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("channel",
                                                         "channel",
                                                         "TRUE if the item is a channel, FALSE otherwise",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-is-layer-mask
   */
  procedure = picman_procedure_new (item_is_layer_mask_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-is-layer-mask");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-is-layer-mask",
                                     "Returns whether the item is a layer mask.",
                                     "This procedure returns TRUE if the specified item is a layer mask.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("layer-mask",
                                                         "layer mask",
                                                         "TRUE if the item is a layer mask, FALSE otherwise",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-is-selection
   */
  procedure = picman_procedure_new (item_is_selection_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-is-selection");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-is-selection",
                                     "Returns whether the item is a selection.",
                                     "This procedure returns TRUE if the specified item is a selection.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("selection",
                                                         "selection",
                                                         "TRUE if the item is a selection, FALSE otherwise",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-is-vectors
   */
  procedure = picman_procedure_new (item_is_vectors_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-is-vectors");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-is-vectors",
                                     "Returns whether the item is a vectors.",
                                     "This procedure returns TRUE if the specified item is a vectors.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("vectors",
                                                         "vectors",
                                                         "TRUE if the item is a vectors, FALSE otherwise",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-is-group
   */
  procedure = picman_procedure_new (item_is_group_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-is-group");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-is-group",
                                     "Returns whether the item is a group item.",
                                     "This procedure returns TRUE if the specified item is a group item which can have children.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2010",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("group",
                                                         "group",
                                                         "TRUE if the item is a group, FALSE otherwise",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-get-parent
   */
  procedure = picman_procedure_new (item_get_parent_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-get-parent");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-get-parent",
                                     "Returns the item's parent item.",
                                     "This procedure returns the item's parent item, if any.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2010",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_item_id ("parent",
                                                            "parent",
                                                            "The item's parent item",
                                                            pdb->picman, FALSE,
                                                            PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-get-children
   */
  procedure = picman_procedure_new (item_get_children_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-get-children");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-get-children",
                                     "Returns the item's list of children.",
                                     "This procedure returns the list of items which are children of the specified item. The order is topmost to bottommost.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2010",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_int32 ("num-children",
                                                          "num children",
                                                          "The item's number of children",
                                                          0, G_MAXINT32, 0,
                                                          PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_int32_array ("child-ids",
                                                                "child ids",
                                                                "The item's list of children",
                                                                PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-get-name
   */
  procedure = picman_procedure_new (item_get_name_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-get-name");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-get-name",
                                     "Get the name of the specified item.",
                                     "This procedure returns the specified item's name.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_string ("name",
                                                           "name",
                                                           "The item name",
                                                           FALSE, FALSE, FALSE,
                                                           NULL,
                                                           PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-set-name
   */
  procedure = picman_procedure_new (item_set_name_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-set-name");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-set-name",
                                     "Set the name of the specified item.",
                                     "This procedure sets the specified item's name.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("name",
                                                       "name",
                                                       "The new item name",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-get-visible
   */
  procedure = picman_procedure_new (item_get_visible_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-get-visible");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-get-visible",
                                     "Get the visibility of the specified item.",
                                     "This procedure returns the specified item's visibility.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("visible",
                                                         "visible",
                                                         "The item visibility",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-set-visible
   */
  procedure = picman_procedure_new (item_set_visible_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-set-visible");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-set-visible",
                                     "Set the visibility of the specified item.",
                                     "This procedure sets the specified item's visibility.",
                                     "Spencer Kimball & Peter Mattis",
                                     "Spencer Kimball & Peter Mattis",
                                     "1995-1996",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("visible",
                                                     "visible",
                                                     "The new item visibility",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-get-linked
   */
  procedure = picman_procedure_new (item_get_linked_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-get-linked");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-get-linked",
                                     "Get the linked state of the specified item.",
                                     "This procedure returns the specified item's linked state.",
                                     "Wolfgang Hofer",
                                     "Wolfgang Hofer",
                                     "1998",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("linked",
                                                         "linked",
                                                         "The item linked state (for moves)",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-set-linked
   */
  procedure = picman_procedure_new (item_set_linked_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-set-linked");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-set-linked",
                                     "Set the linked state of the specified item.",
                                     "This procedure sets the specified item's linked state.",
                                     "Wolfgang Hofer",
                                     "Wolfgang Hofer",
                                     "1998",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("linked",
                                                     "linked",
                                                     "The new item linked state",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-get-lock-content
   */
  procedure = picman_procedure_new (item_get_lock_content_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-get-lock-content");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-get-lock-content",
                                     "Get the 'lock content' state of the specified item.",
                                     "This procedure returns the specified item's lock content state.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2009",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("lock-content",
                                                         "lock content",
                                                         "Whether the item's contents are locked",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-set-lock-content
   */
  procedure = picman_procedure_new (item_set_lock_content_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-set-lock-content");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-set-lock-content",
                                     "Set the 'lock content' state of the specified item.",
                                     "This procedure sets the specified item's lock content state.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2009",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("lock-content",
                                                     "lock content",
                                                     "The new item 'lock content' state",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-get-lock-position
   */
  procedure = picman_procedure_new (item_get_lock_position_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-get-lock-position");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-get-lock-position",
                                     "Get the 'lock position' state of the specified item.",
                                     "This procedure returns the specified item's lock position state.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2012",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_boolean ("lock-position",
                                                         "lock position",
                                                         "Whether the item's position is locked",
                                                         FALSE,
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-set-lock-position
   */
  procedure = picman_procedure_new (item_set_lock_position_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-set-lock-position");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-set-lock-position",
                                     "Set the 'lock position' state of the specified item.",
                                     "This procedure sets the specified item's lock position state.",
                                     "Michael Natterer <mitch@picman.org>",
                                     "Michael Natterer",
                                     "2009",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_boolean ("lock-position",
                                                     "lock position",
                                                     "The new item 'lock position' state",
                                                     FALSE,
                                                     PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-get-tattoo
   */
  procedure = picman_procedure_new (item_get_tattoo_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-get-tattoo");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-get-tattoo",
                                     "Get the tattoo of the specified item.",
                                     "This procedure returns the specified item's tattoo. A tattoo is a unique and permanent identifier attached to a item that can be used to uniquely identify a item within an image even between sessions.",
                                     "Jay Cox",
                                     "Jay Cox",
                                     "1998",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   g_param_spec_uint ("tattoo",
                                                      "tattoo",
                                                      "The item tattoo",
                                                      1, G_MAXUINT32, 1,
                                                      PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-set-tattoo
   */
  procedure = picman_procedure_new (item_set_tattoo_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-set-tattoo");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-set-tattoo",
                                     "Set the tattoo of the specified item.",
                                     "This procedure sets the specified item's tattoo. A tattoo is a unique and permanent identifier attached to a item that can be used to uniquely identify a item within an image even between sessions.",
                                     "Jay Cox",
                                     "Jay Cox",
                                     "1998",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               g_param_spec_uint ("tattoo",
                                                  "tattoo",
                                                  "The new item tattoo",
                                                  1, G_MAXUINT32, 1,
                                                  PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-attach-parasite
   */
  procedure = picman_procedure_new (item_attach_parasite_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-attach-parasite");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-attach-parasite",
                                     "Add a parasite to an item.",
                                     "This procedure attaches a parasite to an item. It has no return values.",
                                     "Jay Cox",
                                     "Jay Cox",
                                     "1998",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_parasite ("parasite",
                                                         "parasite",
                                                         "The parasite to attach to the item",
                                                         PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-detach-parasite
   */
  procedure = picman_procedure_new (item_detach_parasite_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-detach-parasite");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-detach-parasite",
                                     "Removes a parasite from an item.",
                                     "This procedure detaches a parasite from an item. It has no return values.",
                                     "Jay Cox",
                                     "Jay Cox",
                                     "1998",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("name",
                                                       "name",
                                                       "The name of the parasite to detach from the item.",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-get-parasite
   */
  procedure = picman_procedure_new (item_get_parasite_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-get-parasite");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-get-parasite",
                                     "Look up a parasite in an item",
                                     "Finds and returns the parasite that is attached to an item.",
                                     "Jay Cox",
                                     "Jay Cox",
                                     "1998",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_argument (procedure,
                               picman_param_spec_string ("name",
                                                       "name",
                                                       "The name of the parasite to find",
                                                       FALSE, FALSE, FALSE,
                                                       NULL,
                                                       PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_parasite ("parasite",
                                                             "parasite",
                                                             "The found parasite",
                                                             PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);

  /*
   * picman-item-get-parasite-list
   */
  procedure = picman_procedure_new (item_get_parasite_list_invoker);
  picman_object_set_static_name (PICMAN_OBJECT (procedure),
                               "picman-item-get-parasite-list");
  picman_procedure_set_static_strings (procedure,
                                     "picman-item-get-parasite-list",
                                     "List all parasites.",
                                     "Returns a list of all parasites currently attached the an item.",
                                     "Marc Lehmann",
                                     "Marc Lehmann",
                                     "1999",
                                     NULL);
  picman_procedure_add_argument (procedure,
                               picman_param_spec_item_id ("item",
                                                        "item",
                                                        "The item",
                                                        pdb->picman, FALSE,
                                                        PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_int32 ("num-parasites",
                                                          "num parasites",
                                                          "The number of attached parasites",
                                                          0, G_MAXINT32, 0,
                                                          PICMAN_PARAM_READWRITE));
  picman_procedure_add_return_value (procedure,
                                   picman_param_spec_string_array ("parasites",
                                                                 "parasites",
                                                                 "The names of currently attached parasites",
                                                                 PICMAN_PARAM_READWRITE));
  picman_pdb_register_procedure (pdb, procedure);
  g_object_unref (procedure);
}
