# PICMAN - The GNU Image Manipulation Program
# Copyright (C) 1995 Spencer Kimball and Peter Mattis

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# "Perlized" from C source by Manish Singh <yosh@picman.org>

sub image_add_hguide {
    $blurb = 'Add a horizontal guide to an image.';

    $help = <<HELP;
This procedure adds a horizontal guide to an image. It takes the input
image and the y-position of the new guide as parameters. It returns
the guide ID of the new guide.
HELP

    &adam_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'yposition', type => '0 <= int32',
	  desc => "The guide's y-offset from top of image" }
    );

    @outargs = (
	{ name => 'guide', type => 'guide',
	  desc => 'The new guide' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (yposition <= picman_image_get_height (image))
    {
      PicmanGuide *g;

      g = picman_image_add_hguide (image, yposition, TRUE);
      guide = picman_guide_get_ID (g);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub image_add_vguide {
    $blurb = 'Add a vertical guide to an image.';

    $help = <<HELP;
This procedure adds a vertical guide to an image. It takes the input
image and the x-position of the new guide as parameters. It returns
the guide ID of the new guide.
HELP

    &adam_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'xposition', type => '0 <= int32',
	  desc => "The guide's x-offset from left of image" }
    );

    @outargs = (
	{ name => 'guide', type => 'guide',
	  desc => 'The new guide' }
    );

    %invoke = (
	code => <<'CODE'
{
  if (xposition <= picman_image_get_width (image))
    {
      PicmanGuide *g;

      g = picman_image_add_vguide (image, xposition, TRUE);
      guide = picman_guide_get_ID (g);
    }
  else
    success = FALSE;
}
CODE
    );
}

sub image_delete_guide {
    $blurb = 'Deletes a guide from an image.';

    $help = <<'HELP';
This procedure takes an image and a guide ID as input and removes the specified
guide from the specified image.
HELP

    &adam_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'guide', type => 'guide',
	  desc => 'The ID of the guide to be removed' }
    );

    %invoke = (
	code => <<'CODE'
{
  PicmanGuide *g = picman_image_get_guide (image, guide);

  if (g)
    picman_image_remove_guide (image, g, TRUE);
  else
    success = FALSE;
}
CODE
    );
}

sub image_find_next_guide {
    $blurb = 'Find next guide on an image.';

    $help = <<'HELP';
This procedure takes an image and a guide ID as input and finds the guide ID of
the successor of the given guide ID in the image's guide list. If the supplied
guide ID is 0, the procedure will return the first Guide. The procedure will
return 0 if given the final guide ID as an argument or the image has no guides.
HELP

    &adam_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'guide', type => 'guide', no_validate => 1,
	  desc => 'The ID of the current guide (0 if first invocation)' }
    );

    @outargs = (
	{ name => 'next_guide', type => 'guide',
	  desc => "The next guide's ID" }
    );

    %invoke = (
	code => <<'CODE'
{
  PicmanGuide *g = picman_image_get_next_guide (image, guide, &success);

  if (g)
    next_guide = picman_guide_get_ID (g);
}
CODE
    );
}

sub image_get_guide_orientation {
    $blurb = 'Get orientation of a guide on an image.';

    $help = <<'HELP';
This procedure takes an image and a guide ID as input and returns the
orientations of the guide.
HELP

    &adam_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'guide', type => 'guide',
	  desc => 'The guide' }
    );

    @outargs = (
	{ name => 'orientation',
	  type => 'enum PicmanOrientationType (no PICMAN_ORIENTATION_UNKNOWN)',
	  desc => "The guide's orientation",
	  libdef => 'PICMAN_ORIENTATION_UNKNOWN' }
    );

    %invoke = (
	code => <<'CODE'
{
  PicmanGuide *g = picman_image_get_guide (image, guide);

  if (g)
    orientation = picman_guide_get_orientation (g);
  else
    success = FALSE;
}
CODE
    );
}

sub image_get_guide_position {
    $blurb = 'Get position of a guide on an image.';

    $help = <<'HELP';
This procedure takes an image and a guide ID as input and returns the position
of the guide relative to the top or left of the image.
HELP

    &adam_pdb_misc('1998');

    @inargs = (
	{ name => 'image', type => 'image',
	  desc => 'The image' },
	{ name => 'guide', type => 'guide',
	  desc => 'The guide' }
    );

    @outargs = (
	{ name => 'position', type => 'int32', libdef => '-1',
	  desc => "The guide's position relative to top or left of image" }
    );

    %invoke = (
	code => <<'CODE'
{
  PicmanGuide *g = picman_image_get_guide (image, guide);

  if (g)
    position = picman_guide_get_position (g);
  else
    success = FALSE;
}
CODE
    );
}


@headers = qw("core/picmanguide.h" "core/picmanimage-guides.h" "core/picmanimage-undo-push.h");

@procs = qw(image_add_hguide image_add_vguide image_delete_guide
	    image_find_next_guide image_get_guide_orientation
	    image_get_guide_position);

%exports = (app => [@procs], lib => [@procs]);

$desc = 'Guide procedures';
$doc_title = 'picmanguides';
$doc_short_desc = 'Functions for manipulating guides.';
$doc_long_desc = 'Functions for manipulating guides.';

1;
