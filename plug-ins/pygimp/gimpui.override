headers
#include <Python.h>

#define NO_IMPORT_PYGOBJECT
#include <pygobject.h>

#include <libpicman/picman.h>
#undef PICMAN_DISABLE_DEPRECATED
#include <libpicman/picmanui.h>
#define PICMAN_DISABLE_DEPRECATED

#define NO_IMPORT_PYPICMAN
#include "pypicman-api.h"

#define NO_IMPORT_PYPICMANCOLOR
#include "pypicmancolor-api.h"

typedef struct {
    PyObject *constraint;
    PyObject *user_data;
} PyPicmanConstraintData;

typedef struct {
    PyObject *sensitivity_func;
    PyObject *user_data;
} PyPicmanIntSensitivityData;

/* TODO: Add a header for these */
void picmanui_register_classes(PyObject *d);
void picmanui_add_constants(PyObject *module, const gchar *strip_prefix);

static void
pypicman_decref_callback(PyObject* obj) {
    Py_XDECREF (obj);
}

%%
modulename picmanui
%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
import gtk.Object as PyGtkObject_Type
import gtk.Widget as PyGtkWidget_Type
import gtk.Dialog as PyGtkDialog_Type
import gtk.Window as PyGtkWindow_Type
import gtk.Label as PyGtkLabel_Type
import gtk.Button as PyGtkButton_Type
import gtk.ToggleButton as PyGtkToggleButton_Type
import gtk.RadioButton as PyGtkRadioButton_Type
import gtk.SpinButton as PyGtkSpinButton_Type
import gtk.Entry as PyGtkEntry_Type
import gtk.DrawingArea as PyGtkDrawingArea_Type
import gtk.Table as PyGtkTable_Type
import gtk.Frame as PyGtkFrame_Type
import gtk.HBox as PyGtkHBox_Type
import gtk.VBox as PyGtkVBox_Type
import gtk.HPaned as PyGtkHPaned_Type
import gtk.VPaned as PyGtkVPaned_Type
import gtk.Scale as PyGtkScale_Type
import gtk.ProgressBar as PyGtkProgressBar_Type
import gtk.OptionMenu as PyGtkOptionMenu_Type
import gtk.ComboBox as PyGtkComboBox_Type
import gtk.ListStore as PyGtkListStore_Type
import gtk.TreeModel as PyGtkTreeModel_Type
import gtk.CellRenderer as PyGtkCellRenderer_Type
import gtk.CellRendererToggle as PyGtkCellRendererToggle_Type
import picman.Parasite as PyPicmanParasite_Type
%%
ignore
  picman_dialog_add_buttons
  picman_int_combo_box_connect
  picman_color_profile_combo_box_new
  picman_enum_store_new_with_values
  picman_int_combo_box_new_array
%%
ignore-glob
  *_get_type
  *_valist
  picman_resolution_*
%%
ignore-type
  PicmanIntStoreColumns 
%%
override picman_drawable_combo_box_new kwargs
static gboolean
pypicman_drawable_constraint_marshal(gint32 image_id, gint32 drawable_id,
                                   gpointer user_data)
{
    PyObject *img, *drw, *ret;
    gboolean res;
    PyPicmanConstraintData *data = user_data;

    img = pypicman_image_new(image_id);
    if (!img) {
        PyErr_Print();
        return FALSE;
    }

    drw = pypicman_drawable_new(NULL, drawable_id);
    if (!drw) {
        PyErr_Print();
        Py_DECREF(img);
        return FALSE;
    }

    if (data->user_data && data->user_data != Py_None)
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, drw,
                                           data->user_data, NULL);
    else
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, drw, NULL);

    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }

    Py_DECREF(drw);
    Py_DECREF(img);

    return res;
}

static int
_wrap_picman_drawable_combo_box_new(PyGObject *self, PyObject *args,
                                  PyObject *kwargs)
{
    PyObject *constraint = NULL, *user_data = NULL;
    PicmanDrawableConstraintFunc func = NULL;
    PyPicmanConstraintData *data = NULL;

    static char *kwlist[] = { "constraint", "data", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:picmanui.DrawableComboBox.__init__",
                                     kwlist,
                                     &constraint, &user_data))
        return -1;

    if (constraint && constraint != Py_None) {
        if (!PyCallable_Check(constraint)) {
            PyErr_SetString(PyExc_TypeError, "first arg must be callable");
            return -1;
        }

        data = g_new(PyPicmanConstraintData, 1);

        data->constraint = constraint;
        Py_XINCREF(constraint);

        data->user_data = user_data;
        Py_XINCREF(user_data);

        func = pypicman_drawable_constraint_marshal;
    }

    self->obj = (GObject *)picman_drawable_combo_box_new(func, data);

    Py_XDECREF(constraint);
    Py_XDECREF(user_data);
    g_free(data);

    if (pyg_type_from_object((PyObject *)self) != PICMAN_TYPE_DRAWABLE_COMBO_BOX) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing picmanui.DrawableComboBox");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
define PicmanDrawableComboBox.set_active_drawable kwargs
static PyObject *
_wrap_picman_drawable_combo_box_set_active_drawable(PyGObject *self, PyObject *args,
                                                  PyObject *kwargs)
{
    PyPicmanDrawable *drw;

    static char *kwlist[] = { "drawable", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "O!:PicmanDrawableComboBox.set_active_drawable",
                                     kwlist,
                                     PyPicmanDrawable_Type, &drw))
        return NULL;

    if (!picman_int_combo_box_set_active(PICMAN_INT_COMBO_BOX(self->obj), drw->ID)) {
        PyErr_Format(pypicman_error,
                     "Drawable (ID %d) does not exist in PicmanDrawableComboBox",
                     drw->ID);
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define PicmanDrawableComboBox.get_active_drawable noargs
static PyObject *
_wrap_picman_drawable_combo_box_get_active_drawable(PyGObject *self)
{
    int value;

    if (picman_int_combo_box_get_active(PICMAN_INT_COMBO_BOX(self->obj), &value))
        return pypicman_drawable_new(NULL, value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_channel_combo_box_new kwargs
static gboolean
pypicman_channel_constraint_marshal(gint32 image_id, gint32 channel_id,
                                  gpointer user_data)
{
    PyObject *img, *chn, *ret;
    gboolean res;
    PyPicmanConstraintData *data = user_data;

    img = pypicman_image_new(image_id);
    if (!img) {
        PyErr_Print();
        return FALSE;
    }

    chn = pypicman_channel_new(channel_id);
    if (!chn) {
        PyErr_Print();
        Py_DECREF(img);
        return FALSE;
    }

    if (data->user_data && data->user_data != Py_None)
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, chn,
                                           data->user_data, NULL);
    else
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, chn, NULL);

    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }

    Py_DECREF(chn);
    Py_DECREF(img);

    return res;
}

static int
_wrap_picman_channel_combo_box_new(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    PyObject *constraint = NULL, *user_data = NULL;
    PicmanDrawableConstraintFunc func = NULL;
    PyPicmanConstraintData *data = NULL;

    static char *kwlist[] = { "constraint", "data", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:picmanui.ChannelComboBox.__init__",
                                     kwlist,
                                     &constraint, &user_data))
        return -1;

    if (constraint && constraint != Py_None) {
        if (!PyCallable_Check(constraint)) {
            PyErr_SetString(PyExc_TypeError, "first arg must be callable");
            return -1;
        }

        data = g_new(PyPicmanConstraintData, 1);

        data->constraint = constraint;
        Py_INCREF(constraint);

        data->user_data = user_data;
        Py_XINCREF(user_data);

        func = pypicman_channel_constraint_marshal;
    }

    self->obj = (GObject *)picman_channel_combo_box_new(func, data);

    Py_XDECREF(constraint);
    Py_XDECREF(user_data);
    g_free(data);

    if (pyg_type_from_object((PyObject *)self) != PICMAN_TYPE_CHANNEL_COMBO_BOX) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing picmanui.ChannelComboBox");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
define PicmanChannelComboBox.set_active_channel kwargs
static PyObject *
_wrap_picman_channel_combo_box_set_active_channel(PyGObject *self, PyObject *args,
                                                PyObject *kwargs)
{
    PyPicmanChannel *chn;

    static char *kwlist[] = { "channel", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                    "O!:PicmanChannelComboBox.set_active_channel",
                                    kwlist,
                                    PyPicmanChannel_Type, &chn))
        return NULL;

    if (!picman_int_combo_box_set_active(PICMAN_INT_COMBO_BOX(self->obj), chn->ID)) {
        PyErr_Format(pypicman_error,
                     "Channel (ID %d) does not exist in PicmanChannelComboBox",
                     chn->ID);
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define PicmanChannelComboBox.get_active_channel noargs
static PyObject *
_wrap_picman_channel_combo_box_get_active_channel(PyGObject *self)
{
    int value;

    if (picman_int_combo_box_get_active(PICMAN_INT_COMBO_BOX(self->obj), &value))
        return pypicman_channel_new(value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_layer_combo_box_new kwargs
static gboolean
pypicman_layer_constraint_marshal(gint32 image_id, gint32 layer_id,
                                gpointer user_data)
{
    PyObject *img, *lay, *ret;
    gboolean res;
    PyPicmanConstraintData *data = user_data;

    img = pypicman_image_new(image_id);
    if (!img) {
        PyErr_Print();
        return FALSE;
    }

    lay = pypicman_layer_new(layer_id);
    if (!lay) {
        PyErr_Print();
        Py_DECREF(img);
        return FALSE;
    }

    if (data->user_data && data->user_data != Py_None)
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, lay,
                                           data->user_data, NULL);
    else
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, lay, NULL);

    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }

    Py_DECREF(lay);
    Py_DECREF(img);

    return res;
}

static int
_wrap_picman_layer_combo_box_new(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    PyObject *constraint = NULL, *user_data = NULL;
    PicmanDrawableConstraintFunc func = NULL;
    PyPicmanConstraintData *data = NULL;

    static char *kwlist[] = { "constraint", "data", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:picmanui.LayerComboBox.__init__",
                                     kwlist,
                                     &constraint, &user_data))
        return -1;

    if (constraint && constraint != Py_None) {
        if (!PyCallable_Check(constraint)) {
            PyErr_SetString(PyExc_TypeError, "first arg must be callable");
            return -1;
        }

        data = g_new(PyPicmanConstraintData, 1);

        data->constraint = constraint;
        Py_INCREF(constraint);

        data->user_data = user_data;
        Py_XINCREF(user_data);

        func = pypicman_layer_constraint_marshal;
    }

    self->obj = (GObject *)picman_layer_combo_box_new(func, data);

    Py_XDECREF(constraint);
    Py_XDECREF(user_data);
    g_free(data);

    if (pyg_type_from_object((PyObject *)self) != PICMAN_TYPE_LAYER_COMBO_BOX) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing picmanui.LayerComboBox");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
define PicmanLayerComboBox.set_active_layer kwargs
static PyObject *
_wrap_picman_layer_combo_box_set_active_layer(PyGObject *self, PyObject *args,
                                            PyObject *kwargs)
{
    PyPicmanLayer *lay;

    static char *kwlist[] = { "layer", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "O!:PicmanLayerComboBox.set_active_layer",
                                     kwlist,
                                     PyPicmanLayer_Type, &lay))
        return NULL;

    if (!picman_int_combo_box_set_active(PICMAN_INT_COMBO_BOX(self->obj), lay->ID)) {
        PyErr_Format(pypicman_error,
                     "Layer (ID %d) does not exist in PicmanLayerComboBox",
                     lay->ID);
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define PicmanLayerComboBox.get_active_layer noargs
static PyObject *
_wrap_picman_layer_combo_box_get_active_layer(PyGObject *self)
{
    int value;

    if (picman_int_combo_box_get_active(PICMAN_INT_COMBO_BOX(self->obj), &value))
        return pypicman_layer_new(value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_vectors_combo_box_new kwargs
static gboolean
pypicman_vectors_constraint_marshal(gint32 image_id, gint32 vectors_id,
                                  gpointer user_data)
{
    PyObject *img, *vect, *ret;
    gboolean res;
    PyPicmanConstraintData *data = user_data;

    img = pypicman_image_new(image_id);
    if (!img) {
        PyErr_Print();
        return FALSE;
    }

    vect = pypicman_vectors_new(vectors_id);
    if (!vect) {
        PyErr_Print();
        Py_DECREF(img);
        return FALSE;
    }

    if (data->user_data && data->user_data != Py_None)
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, vect,
                                           data->user_data, NULL);
    else
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, vect, NULL);

    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }

    Py_DECREF(vect);
    Py_DECREF(img);

    return res;
}

static int
_wrap_picman_vectors_combo_box_new(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    PyObject *constraint = NULL, *user_data = NULL;
    PicmanVectorsConstraintFunc func = NULL;
    PyPicmanConstraintData *data = NULL;

    static char *kwlist[] = { "constraint", "data", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:picmanui.VectorsComboBox.__init__",
                                     kwlist,
                                     &constraint, &user_data))
        return -1;

    if (constraint && constraint != Py_None) {
        if (!PyCallable_Check(constraint)) {
            PyErr_SetString(PyExc_TypeError, "first arg must be callable");
            return -1;
        }

        data = g_new(PyPicmanConstraintData, 1);

        data->constraint = constraint;
        Py_INCREF(constraint);

        data->user_data = user_data;
        Py_XINCREF(user_data);

        func = pypicman_vectors_constraint_marshal;
    }

    self->obj = (GObject *)picman_vectors_combo_box_new(func, data);

    Py_XDECREF(constraint);
    Py_XDECREF(user_data);
    g_free(data);

    if (pyg_type_from_object((PyObject *)self) != PICMAN_TYPE_VECTORS_COMBO_BOX) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing picmanui.VectorsComboBox");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
define PicmanVectorsComboBox.set_active_vectors kwargs
static PyObject *
_wrap_picman_vectors_combo_box_set_active_vectors(PyGObject *self, PyObject *args,
                                                PyObject *kwargs)
{
    PyPicmanVectors *vect;

    static char *kwlist[] = { "vectors", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                   "O!:PicmanVectorsComboBox.set_active_vectors",
                                   kwlist,
                                   PyPicmanVectors_Type, &vect))
        return NULL;

    if (!picman_int_combo_box_set_active(PICMAN_INT_COMBO_BOX(self->obj), vect->ID)) {
        PyErr_Format(pypicman_error,
                     "Vectors (ID %d) does not exist in PicmanVectorsComboBox",
                     vect->ID);
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define PicmanVectorsComboBox.get_active_vectors noargs
static PyObject *
_wrap_picman_vectors_combo_box_get_active_vectors(PyGObject *self)
{
    int value;

    if (picman_int_combo_box_get_active(PICMAN_INT_COMBO_BOX(self->obj), &value))
        return pypicman_vectors_new(value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_image_combo_box_new kwargs
static gboolean
pypicman_image_constraint_marshal(gint32 image_id, gpointer user_data)
{
    PyObject *img, *ret;
    gboolean res;
    PyPicmanConstraintData *data = user_data;

    img = pypicman_image_new(image_id);
    if (!img) {
        PyErr_Print();
        return FALSE;
    }

    if (data->user_data && data->user_data != Py_None)
        ret = PyObject_CallFunctionObjArgs(data->constraint, img,
                                           data->user_data, NULL);
    else
        ret = PyObject_CallFunctionObjArgs(data->constraint, img, NULL);

    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }

    Py_DECREF(img);

    return res;
}

static int
_wrap_picman_image_combo_box_new(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    PyObject *constraint = NULL, *user_data = NULL;
    PicmanImageConstraintFunc func = NULL;
    PyPicmanConstraintData *data = NULL;

    static char *kwlist[] = { "constraint", "data", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|OO:picmanui.ImageComboBox.__init__",
                                     kwlist,
                                     &constraint, &user_data))
        return -1;

    if (constraint && constraint != Py_None) {
        if (!PyCallable_Check(constraint)) {
            PyErr_SetString(PyExc_TypeError, "first arg must be callable");
            return -1;
        }

        data = g_new(PyPicmanConstraintData, 1);

        data->constraint = constraint;
        Py_INCREF(constraint);

        data->user_data = user_data;
        Py_XINCREF(user_data);

        func = pypicman_image_constraint_marshal;
    }

    self->obj = (GObject *)picman_image_combo_box_new(func, data);

    Py_XDECREF(constraint);
    Py_XDECREF(user_data);
    g_free(data);

    if (pyg_type_from_object((PyObject *)self) != PICMAN_TYPE_IMAGE_COMBO_BOX) {
        PyErr_SetString(PyExc_RuntimeError, "__gobject_init__ must be used "
                        "when subclassing picmanui.ImageComboBox");
        return -1;
    }

    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
define PicmanImageComboBox.set_active_image kwargs
static PyObject *
_wrap_picman_image_combo_box_set_active_image(PyGObject *self, PyObject *args,
                                            PyObject *kwargs)
{
    PyPicmanImage *img;

    static char *kwlist[] = { "image", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "O!:PicmanImageComboBox.set_active_image",
                                     kwlist,
                                     PyPicmanImage_Type, &img))
        return NULL;

    if (!picman_int_combo_box_set_active(PICMAN_INT_COMBO_BOX(self->obj), img->ID)) {
        PyErr_Format(pypicman_error,
                     "Image (ID %d) does not exist in PicmanImageComboBox",
                     img->ID);
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
define PicmanImageComboBox.get_active_image noargs
static PyObject *
_wrap_picman_image_combo_box_get_active_image(PyGObject *self)
{
    int value;

    if (picman_int_combo_box_get_active(PICMAN_INT_COMBO_BOX(self->obj), &value))
        return pypicman_image_new(value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_dialog_new kwargs
static void
pypicman_help_func_marshal(const gchar *help_id, gpointer help_data)
{
    GObject *dialog = help_data;
    PyObject *py_dialog, *help_func, *ret;

    py_dialog = g_object_get_data(dialog, "pypicman-dialog-pyobject");
    help_func = g_object_get_data(dialog, "pypicman-dialog-help_func");

    ret = PyObject_CallFunction(help_func, "sO", help_id, py_dialog);

    if (ret)
        Py_DECREF(ret);
    else
        PyErr_Print();
}

static void
pypicman_help_func_destroy(gpointer data)
{
    PyObject *help_func = data;

    Py_DECREF(help_func);
}

static void
pypicman_dialog_close(GtkWidget *widget)
{
    /* Synthesize delete_event to close dialog. */

    if (gtk_widget_get_window (widget)) {
        GdkEvent *event = gdk_event_new(GDK_DELETE);

        event->any.window     = g_object_ref (gtk_widget_get_window (widget));
        event->any.send_event = TRUE;

        gtk_main_do_event(event);
        gdk_event_free(event);
    }
}

static int
_wrap_picman_dialog_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    gchar *title, *role;
    PyGObject *py_window = NULL;
    PyObject *py_flags = NULL, *py_buttons = Py_None;
    PyObject *help_func = NULL;
    gchar *help_id = NULL;
    GtkDialogFlags flags = 0;
    int len, i;
    GtkWidget *parent;
    PicmanHelpFunc func;

    static char *kwlist[] = { "title", "role", "parent", "flags",
                              "help_func", "help_id", "buttons", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zz|OOOzO:picmanui.PicmanDialog.__init__",
                                     kwlist,
                                     &title, &role, &py_window, &py_flags,
                                     &help_func, &help_id, &py_buttons))
        return -1;

    if (py_window == NULL || (PyObject*)py_window == Py_None)
        parent = NULL;
    else if (pygobject_check(py_window, &PyGtkWindow_Type))
        parent = GTK_WIDGET(py_window->obj);
    else {
        PyErr_SetString(PyExc_TypeError, "parent must be a GtkWindow or None");
        return -1;
    }

    if (pyg_flags_get_value(GTK_TYPE_DIALOG_FLAGS, py_flags, (gint *)&flags))
        return -1;

    if (py_buttons == Py_None)
        len = 0;
    else if (PyTuple_Check(py_buttons))
        len = PyTuple_Size(py_buttons);
    else {
        PyErr_SetString(PyExc_TypeError, "buttons must be a tuple containing text/response pairs or None");
        return -1;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }

    if (help_func) {
        if (help_func != Py_None) {
            if (!PyCallable_Check(help_func)) {
                PyErr_SetString(PyExc_TypeError, "help_func must be callable");
                return -1;
            }

            func = pypicman_help_func_marshal;

       } else {
            func = picman_standard_help_func;
        }
    } else {
        func = picman_standard_help_func;
    }

    pygobject_construct(self,
                        "title",     title,
                        "role",      role,
                        "modal",     (flags & GTK_DIALOG_MODAL),
                        "help-func", func,
                        "help-id",   help_id,
                        NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create PicmanDialog object");
        return -1;
    }

   if (parent) {
        if (GTK_IS_WINDOW(parent))
            gtk_window_set_transient_for(GTK_WINDOW(self->obj),
                                         GTK_WINDOW(parent));
        else
            gtk_window_set_screen(GTK_WINDOW(self->obj),
                                  gtk_widget_get_screen(parent));

        if (flags & GTK_DIALOG_DESTROY_WITH_PARENT)
            g_signal_connect_object(parent, "destroy",
                                    G_CALLBACK(pypicman_dialog_close),
                                    self->obj, G_CONNECT_SWAPPED);
    }

    for (i = 0; i < len; i += 2) {
        PyObject *text = PyTuple_GetItem(py_buttons, i);
        PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
        if (!PyString_Check(text) && !PyUnicode_Check(text)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each text/response id pair "
                            "must be a string");
            return -1;
        }
        if (!PyInt_Check(id)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each text/response id pair "
                            "must be a number");
            return -1;
        }

        picman_dialog_add_button(PICMAN_DIALOG(self->obj), PyString_AsString(text),
                               PyInt_AsLong(id));
    }

    if (help_func && help_func != Py_None) {
        g_object_set_data(self->obj, "pypicman-dialog-help-data", self);

        Py_INCREF(help_func);
        g_object_set_data_full(self->obj, "pypicman-dialog-help-func",
                               help_func, pypicman_help_func_destroy);
    }

    return 0;
}
%%
new-constructor PICMAN_TYPE_DIALOG
%%
override picman_color_button_get_color noargs
static PyObject *
_wrap_picman_color_button_get_color(PyGObject *self)
{
    PicmanRGB rgb;

    picman_color_button_get_color(PICMAN_COLOR_BUTTON(self->obj), &rgb);

    return pypicman_rgb_new(&rgb);
}
%%
override picman_brush_select_button_get_brush noargs
static PyObject *
_wrap_picman_brush_select_button_get_brush(PyGObject *self)
{
    const gchar *brush_name;
    gdouble opacity;
    gint spacing;
    PicmanLayerModeEffects paint_mode;

    brush_name =
        picman_brush_select_button_get_brush(PICMAN_BRUSH_SELECT_BUTTON(self->obj),
                                           &opacity, &spacing, &paint_mode);

    return Py_BuildValue("(sdiN)", brush_name, opacity, spacing,
                         pyg_enum_from_gtype(PICMAN_TYPE_LAYER_MODE_EFFECTS,
                                             paint_mode));
}
%%
override picman_window_set_transient
static PyObject *
_wrap_picman_window_set_transient(PyGObject *self)
{
    picman_window_set_transient(GTK_WINDOW(self->obj));
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_color_button_new kwargs
static int
_wrap_picman_color_button_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    gchar *title = NULL;
    gint width = -1, height = -1;
    PyObject *py_color = NULL, *py_type = NULL;
    PicmanRGB *color, default_color = { 0.0, 0.0, 0.0, 100.0 };
    PicmanColorAreaType type;
    
    static char *kwlist[] = { "title", "width", "height", "color", "type",
                              NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|ziiOO:picmanui.ColorButton.__init__",
                                     kwlist,
                                     &title, &width, &height,
                                     &py_color, &py_type))
        return -1;

    if (py_color == NULL || (PyObject*)py_color == Py_None)
        color = &default_color;
    else if (pyg_boxed_check(py_color, PICMAN_TYPE_RGB))
        color = pyg_boxed_get(py_color, PicmanRGB);
    else {
        PyErr_SetString(PyExc_TypeError, "color should be a PicmanRGB or None");
        return -1;
    }

    if (py_type == NULL || (PyObject*)py_type == Py_None)
       type = PICMAN_COLOR_AREA_FLAT;
    else if (pyg_enum_get_value(PICMAN_TYPE_COLOR_AREA_TYPE, py_type,
                                (gint*)&type))
       return -1;

    if (pygobject_construct(self,
                            "title",       title,
                            "type",        type,
                            "color",       color,
                            "area-width",  width,
			    "area-height", height,
                            NULL))
        return -1;

    return 0;
}
%%
new-constructor PICMAN_TYPE_COLOR_BUTTON
%%
override picman_color_scale_new kwargs
static int
_wrap_picman_color_scale_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_orientation, *py_channel;
    GtkOrientation orientation;
    PicmanColorSelectorChannel channel;

    static char *kwlist[] = { "orientation", "channel", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "OO:picmanui.ColorScale.__init__",
                                     kwlist,
                                     &py_orientation, &py_channel))
        return -1;

    if (pyg_enum_get_value(GTK_TYPE_ORIENTATION, py_orientation,
                           (gint*)&orientation))
        return -1;

    if (pyg_enum_get_value(PICMAN_TYPE_COLOR_SELECTOR_CHANNEL, py_channel, 
                           (gint*)&channel))
        return -1;

    if (pygobject_construct(self,
                            "orientation", orientation,
                            "channel",     channel,
                            NULL));
        return -1;

    gtk_range_set_flippable (GTK_RANGE (self->obj),
                             orientation == GTK_ORIENTATION_HORIZONTAL);
    
    return 0;
}
%%
new-constructor PICMAN_TYPE_COLOR_SCALE
%%
override picman_enum_label_new kwargs
static int
_wrap_picman_enum_label_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_enum_type = NULL;
    GType enum_type;
    gint value;

    static char *kwlist[] = { "enum_type", "value", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "Oi:picmanui.PicmanEnumLabel.__init__",
                                     kwlist,
                                     &py_enum_type, &value))
        return -1;

    if ((enum_type = pyg_type_from_object(py_enum_type)) == 0)
        return -1;

    if (pygobject_construct(self,
                            "enum-type",  enum_type,
                            "enum-value", value,
                            NULL))
        return -1;

    return 0; 
}
%%
new-constructor PICMAN_TYPE_ENUM_LABEL
%%
override picman_int_combo_box_new kwargs
static int
_wrap_picman_int_combo_box_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_items = NULL;
    int len, i;

    static char *kwlist[] = { "items", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "|O:picmanui.IntComboBox.__init__",
                                     kwlist,
                                     &py_items))
        return -1; 

    if (py_items == NULL || py_items == Py_None)
        len = 0;
    else if (PyTuple_Check(py_items))
        len = PyTuple_Size(py_items);
    else {
        PyErr_SetString(PyExc_TypeError,
                        "items must be a tuple containing label/value pairs "
                        "or None");
        return -1;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "items tuple must contain label/value pairs");
        return -1;
    }

    if (pygobject_construct(self, NULL))
        return -1;

    for (i = 0; i < len; i += 2) {
        PyObject *label = PyTuple_GetItem(py_items, i);
        PyObject *value = PyTuple_GetItem(py_items, i + 1);

        if (!PyString_Check(label)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each label/value pair "
                            "must be a string");
            return -1;
        }

        if (!PyInt_Check(value)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each label/value pair "
                            "must be a number");
            return -1;
        }

        picman_int_combo_box_append(PICMAN_INT_COMBO_BOX(self->obj),
                                  PICMAN_INT_STORE_LABEL,
                                  PyString_AsString(label),
                                  PICMAN_INT_STORE_VALUE,
                                  PyInt_AsLong(value),
                                  -1);
    }

    return 0;
}
%%
new-constructor PICMAN_TYPE_INT_COMBO_BOX
%%
override picman_int_combo_box_set_sensitivity kwargs
static gboolean
pypicman_int_combo_box_sensitivity_marshal(gint value, gpointer user_data)
{
    PyObject *py_value;
    PyPicmanIntSensitivityData *data;
    PyObject *ret;
    gboolean res;

    data = user_data;

    py_value = PyInt_FromLong(value);

    ret = PyObject_CallFunctionObjArgs(data->sensitivity_func, py_value,
                                       data->user_data, NULL);
    
    if (!ret) {
        PyErr_Print();
        res = FALSE;
    } else {
        res = PyObject_IsTrue(ret);
        Py_DECREF(ret);
    }

    Py_DECREF(py_value);

    return res;
}

static void
pypicman_int_combo_box_sensitivity_data_destroy(gpointer user_data)
{
    PyPicmanIntSensitivityData *data;
    data = user_data;

    Py_DECREF(data->sensitivity_func);
    Py_XDECREF(data->user_data);

    g_free(data);
}

static PyObject *
_wrap_picman_int_combo_box_set_sensitivity(PyGObject *self, PyObject *args,
                                         PyObject *kwargs)
{
    PyObject *py_sensitivity_func;
    PyObject *py_user_data = NULL;
    PyPicmanIntSensitivityData *data;

    static char *kwlist[] = { "sensitivity_func", "user_data", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "O|O:PicmanIntComboBox.set_sensitivity",
                                     kwlist, &py_sensitivity_func,
                                     &py_user_data))
        return NULL;

    if (!PyCallable_Check(py_sensitivity_func)) {
        PyErr_SetString(PyExc_TypeError, "first argument must be callable.");
        return NULL;
    }

    data = g_new(PyPicmanIntSensitivityData, 1);

    data->sensitivity_func = py_sensitivity_func;
    Py_INCREF(data->sensitivity_func);
    
   if (py_user_data == NULL || py_user_data == Py_None)
        data->user_data = NULL;
    else {
       data->user_data = py_user_data;
       Py_INCREF(data->user_data);
    }

    picman_int_combo_box_set_sensitivity(PICMAN_INT_COMBO_BOX(self->obj),
                                pypicman_int_combo_box_sensitivity_marshal,
                                data,
                                pypicman_int_combo_box_sensitivity_data_destroy);
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_int_combo_box_get_active noargs
static PyObject *
_wrap_picman_int_combo_box_get_active(PyGObject *self)
{
    int value;

    if (picman_int_combo_box_get_active(PICMAN_INT_COMBO_BOX(self->obj), &value))
        return PyLong_FromLong(value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_int_combo_box_set_active kwargs
static PyObject *
_wrap_picman_int_combo_box_set_active(PyGObject *self, PyObject *args,
                                    PyObject *kwargs)
{
    int value;

    static char *kwlist[] = { "value", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "i:PicmanIntComboBox.set_active", kwlist,
                                     &value))
        return NULL;

    if (!picman_int_combo_box_set_active(PICMAN_INT_COMBO_BOX(self->obj), value)) {
        PyErr_Format(pypicman_error,
                     "Value %d does not exist in PicmanIntComboBox",
                     value);
        return NULL;
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_int_combo_box_append kwargs
static PyObject *
_wrap_picman_int_combo_box_append(PyGObject *self, PyObject *args,
                                PyObject *kwargs)
{
    PyObject *py_items;
    int i, len;

    static char *kwlist[] = { "items", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:picmanui.IntComboBox.append",
                                     kwlist,
                                     &py_items))
        return NULL; 

    if (py_items == NULL || py_items == Py_None)
        len = 0;
    else if (PyTuple_Check(py_items))
        len = PyTuple_Size(py_items);
    else {
        PyErr_SetString(PyExc_TypeError,
                        "items must be a tuple containing label/value pairs "
                        "or None");
        return NULL;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "items tuple must contain label/value pairs");
        return NULL;
    }

    for (i = 0; i < len; i += 2) {
        PyObject *label = PyTuple_GetItem(py_items, i);
        PyObject *value = PyTuple_GetItem(py_items, i + 1);

        if (!PyString_Check(label)) {
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each label/value pair "
                            "must be a string");
            return NULL;
        }

        if (!PyInt_Check(value)) {
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each label/value pair "
                            "must be a number");
            return NULL;
        }

        picman_int_combo_box_append(PICMAN_INT_COMBO_BOX(self->obj),
                                  PICMAN_INT_STORE_LABEL,
                                  PyString_AsString(label),
                                  PICMAN_INT_STORE_VALUE,
                                  PyInt_AsLong(value),
                                  -1);
    }
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_int_combo_box_prepend kwargs
static PyObject *
_wrap_picman_int_combo_box_prepend(PyGObject *self, PyObject *args,
                                 PyObject *kwargs)
{
    PyObject *py_items;
    int i, len;

    static char *kwlist[] = { "items", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O:picmanui.IntComboBox.prepend",
                                     kwlist,
                                     &py_items))
        return NULL; 

    if (py_items == NULL || py_items == Py_None)
        len = 0;
    else if (PyTuple_Check(py_items))
        len = PyTuple_Size(py_items);
    else {
        PyErr_SetString(PyExc_TypeError,
                        "items must be a tuple containing label/value pairs "
                        "or None");
        return NULL;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "items tuple must contain label/value pairs");
        return NULL;
    }

    for (i = 0; i < len; i += 2) {
        PyObject *label = PyTuple_GetItem(py_items, i);
        PyObject *value = PyTuple_GetItem(py_items, i + 1);

        if (!PyString_Check(label)) {
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each label/value pair "
                            "must be a string");
            return NULL;
        }

        if (!PyInt_Check(value)) {
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each label/value pair "
                            "must be a number");
            return NULL;
        }

        picman_int_combo_box_prepend(PICMAN_INT_COMBO_BOX(self->obj),
                                  PICMAN_INT_STORE_LABEL,
                                  PyString_AsString(label),
                                  PICMAN_INT_STORE_VALUE,
                                  PyInt_AsLong(value),
                                  -1);
    }
    
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_browser_add_search_types args
static PyObject *
_wrap_picman_browser_add_search_types(PyGObject *self, PyObject *args)
{
    PicmanBrowser *browser;
    int len, i;
    PyObject *element;
    gchar *label;
    gint id;

    browser = PICMAN_BROWSER(self->obj);

    len = PyTuple_Size(args);

    for (i = 0; i < len; ++i) {
        element = PyTuple_GetItem(args, i);
        if (!PyTuple_Check(element)) {
            PyErr_SetString(PyExc_TypeError, "PicmanBrowser.add_search_types: Arguments must be tuples");
            return NULL;
        }
        if (!PyArg_ParseTuple(element, "si",  &label, &id))
            return NULL;
        picman_browser_add_search_types(browser, label, id, NULL);
    }

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_proc_browser_dialog_new kwargs
static int
_wrap_picman_proc_browser_dialog_new(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    gchar *title, *role;
    PyObject *py_buttons = Py_None;
    PyObject *help_func = NULL;
    gchar *help_id = NULL;
    int len, i;
    PicmanHelpFunc func;

    static char *kwlist[] = { "title", "role", "help_func", "help_id",
                              "buttons", NULL };

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "zz|OzO:picmanui.PicmanProcBrowserDialog.__init__",
                                     kwlist,
                                     &title, &role, &help_func, &help_id,
                                     &py_buttons))
        return -1;

    if (py_buttons == Py_None)
        len = 0;
    else if (PyTuple_Check(py_buttons))
        len = PyTuple_Size(py_buttons);
    else {
        PyErr_SetString(PyExc_TypeError,
                        "buttons must be a tuple containing text/response "
                        "pairs or None");
        return -1;
    }

    if (len % 2) {
        PyErr_SetString(PyExc_RuntimeError,
                        "buttons tuple must contain text/response id pairs");
        return -1;
    }

    if (help_func) {
        if (help_func != Py_None) {
            if (!PyCallable_Check(help_func)) {
                PyErr_SetString(PyExc_TypeError, "help_func must be callable");
                return -1;
            }

            func = pypicman_help_func_marshal;

       } else {
            func = picman_standard_help_func;
        }
    } else {
        func = picman_standard_help_func;
    }

    pygobject_construct(self,
                        "title",     title,
                        "role",      role,
                        "help-func", func,
                        "help-id",   help_id,
                        NULL);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create PicmanProcBrowserDialog object");
        return -1;
    }

    for (i = 0; i < len; i += 2) {
        PyObject *text = PyTuple_GetItem(py_buttons, i);
        PyObject *id = PyTuple_GetItem(py_buttons, i + 1);
        if (!PyString_Check(text) && !PyUnicode_Check(text)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "first member of each text/response id pair "
                            "must be a string");
            return -1;
        }
        if (!PyInt_Check(id)) {
            gtk_object_destroy(GTK_OBJECT(self->obj));
            self->obj = NULL;
            PyErr_SetString(PyExc_RuntimeError,
                            "second member of each text/response id pair "
                            "must be a number");
            return -1;
        }

        picman_dialog_add_button(PICMAN_DIALOG(self->obj), PyString_AsString(text),
                               PyInt_AsLong(id));
    }

    if (help_func && help_func != Py_None) {
        g_object_set_data(self->obj, "pypicman-dialog-help-data", self);

        Py_INCREF(help_func);
        g_object_set_data_full(self->obj, "pypicman-dialog-help-func",
                               help_func, pypicman_help_func_destroy);
    }

    g_signal_emit_by_name(PICMAN_PROC_BROWSER_DIALOG(self->obj)->browser,
                          "search", "", 0, self->obj);
    return 0;
}
%%
new-constructor PICMAN_TYPE_PROC_BROWSER_DIALOG
%%
override picman_number_pair_entry_get_values noargs
static PyObject *
_wrap_picman_number_pair_entry_get_values(PyGObject *self)
{
    gdouble left, right;

    picman_number_pair_entry_get_values(PICMAN_NUMBER_PAIR_ENTRY(self->obj),
                                      &left, &right);

    return Py_BuildValue("(dd)", left, right);   
}
%%
override picman_number_pair_entry_get_default_values noargs
static PyObject *
_wrap_picman_number_pair_entry_get_default_values(PyGObject *self)
{
    gdouble left, right;

    picman_number_pair_entry_get_default_values(
                                             PICMAN_NUMBER_PAIR_ENTRY(self->obj),
                                             &left, &right);

    return Py_BuildValue("(dd)", left, right);
}
%%
override picman_number_pair_entry_get_aspect noargs
static PyObject *
_wrap_picman_number_pair_entry_get_aspect(PyGObject *self)
{
    PicmanAspectType aspect;

    aspect =
          picman_number_pair_entry_get_aspect(PICMAN_NUMBER_PAIR_ENTRY(self->obj));

    return pyg_enum_from_gtype(PICMAN_TYPE_ASPECT_TYPE, aspect);
}
%%
override picman_number_pair_entry_set_aspect kwargs
static PyObject *
_wrap_picman_number_pair_entry_set_aspect(PyGObject *self, PyObject *args,
                                        PyObject *kwargs)
{
    PyObject *py_aspect;
    PicmanAspectType aspect;

    static char *kwlist[] = {"aspect", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "O:PicmanNumberPairEntry.set_aspect",
                                    kwlist, &py_aspect))
        return NULL;

    if (pyg_enum_get_value(PICMAN_TYPE_ASPECT_TYPE, py_aspect, (gint*)&aspect))
    {
        Py_XDECREF(py_aspect);
        return NULL;
    }

    picman_number_pair_entry_set_aspect(PICMAN_NUMBER_PAIR_ENTRY(self->obj),
                                      aspect);

    Py_DECREF(py_aspect);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_page_selector_get_selected_pages noargs
static PyObject *
_wrap_picman_page_selector_get_selected_pages(PyGObject *self)
{
    gint *selected_pages;
    gint n_selected_pages;
    PyObject *py_selected_pages;
    int i;

    selected_pages = picman_page_selector_get_selected_pages(
                                                PICMAN_PAGE_SELECTOR (self->obj),
                                                &n_selected_pages);
    
    py_selected_pages = PyTuple_New(n_selected_pages);
    for (i = 0; i < n_selected_pages; ++i)
        PyTuple_SetItem(py_selected_pages, i,
                        PyInt_FromLong(selected_pages[i]));

    g_free(selected_pages);

    return py_selected_pages;
}
%%
override picman_preview_get_position noargs
static PyObject *
_wrap_picman_preview_get_position(PyGObject *self)
{
    gint x;
    gint y;
  
    picman_preview_get_position(PICMAN_PREVIEW(self->obj), &x, &y);

    return Py_BuildValue("(ii)", x, y);
}
%%
override picman_preview_get_size noargs
static PyObject *
_wrap_picman_preview_get_size(PyGObject *self)
{
    gint width;
    gint height;
  
    picman_preview_get_size(PICMAN_PREVIEW(self->obj), &width, &height);

    return Py_BuildValue("(ii)", width, height);
}
%%
override picman_preview_transform kwargs
static PyObject *
_wrap_picman_preview_transform(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    gint src_x;
    gint src_y;
    gint dest_x;
    gint dest_y;

    static char *kwlist[] = {"x", "y", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "ii:PicmanPreview.transform",
                                     kwlist, &src_x, &src_y))
        return NULL;

    picman_preview_transform(PICMAN_PREVIEW(self->obj), src_x, src_y, &dest_x,
                           &dest_y);

    return Py_BuildValue("(ii)", dest_x, dest_y);
}
%%
override picman_preview_untransform kwargs
static PyObject *
_wrap_picman_preview_untransform(PyGObject *self, PyObject *args,
                               PyObject *kwargs)
{
    gint src_x;
    gint src_y;
    gint dest_x;
    gint dest_y;

    static char *kwlist[] = {"x", "y", NULL};
    
    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "ii:PicmanPreview.untransform",
                                     kwlist, &src_x, &src_y))
        return NULL;

    picman_preview_untransform(PICMAN_PREVIEW(self->obj), src_x, src_y, &dest_x,
                             &dest_y);

    return Py_BuildValue("(ii)", dest_x, dest_y);
}
%%
override picman_zoom_model_get_fraction noargs
static PyObject *
_wrap_picman_zoom_model_get_fraction(PyGObject *self)
{
    gint numerator;
    gint denominator;

    picman_zoom_model_get_fraction(PICMAN_ZOOM_MODEL(self->obj), &numerator,
                                 &denominator);

    return Py_BuildValue("(ii)", numerator, denominator);
}
%%
override picman_drawable_preview_get_drawable noargs
static PyObject *
_wrap_picman_drawable_preview_get_drawable(PyGObject *self)
{
    PyObject *drawable;
    
    drawable = g_object_get_data(self->obj, 
                                 "pypicman-drawable-preview-pydrawable");
    Py_INCREF(drawable);
    return drawable;
}
%%
override picman_zoom_preview_get_drawable noargs
static PyObject *
_wrap_picman_zoom_preview_get_drawable(PyGObject *self)
{
    PyObject *drawable;
    
    drawable = g_object_get_data(self->obj,
                                 "pypicman-zoom-preview-pydrawable");
    Py_INCREF(drawable);
    return drawable;
}
%%
override picman_drawable_preview_draw_region kwargs
static PyObject *
_wrap_picman_drawable_preview_draw_region(PyGObject *self, PyObject *args,
                                        PyObject *kwargs)
{
/*    PyPicmanPixelRgn *pypixelrgn;

    static char *kwlist[] = {"drawable", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                    "O!:PicmanDrawablePreview.draw_region",
                                    kwlist, PyPicmanPixelRgn_Type, &pypixelrgn))
        return NULL;

    picman_drawable_preview_draw_region(PICMAN_DRAWABLE_PREVIEW(self->obj),
                                      &pypixelrgn->pr);
*/
    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_int_store_lookup_by_value
static PyObject *
_wrap_picman_int_store_lookup_by_value(PyGObject *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *kwlist[] = { "value", NULL };
    int value, ret;
    GtkTreeIter iter;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                               "i:PicmanIntStore.picman_int_store_lookup_by_value",
                               kwlist, &value))
        return NULL;

    ret = picman_int_store_lookup_by_value(GTK_TREE_MODEL(self->obj), value,
                                         &iter);
    if (ret)
        pyg_boxed_new(GTK_TYPE_TREE_ITER, &iter, TRUE, TRUE);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_memsize_entry_new
static int
_wrap_picman_memsize_entry_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "value", "lower", "upper", NULL };
    guint64 value, lower, upper;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "LLL:PicmanMemsizeEntry.__init__",
                                     kwlist, &value, &lower, &upper))
        return -1;
    
    self->obj = (GObject *)picman_memsize_entry_new(value, lower, upper);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError,
                        "could not create PicmanMemsizeEntry object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override picman_memsize_entry_set_value
static PyObject *
_wrap_picman_memsize_entry_set_value(PyGObject *self, PyObject *args,
                                   PyObject *kwargs)
{
    static char *kwlist[] = { "value", NULL };
    guint64 value;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, 
                                     "L:PicmanMemsizeEntry.set_value",
                                     kwlist, &value))
        return NULL;

    picman_memsize_entry_set_value(PICMAN_MEMSIZE_ENTRY(self->obj), value);

    Py_INCREF(Py_None);
    return Py_None;
}
%%
override picman_color_area_get_color noargs
static PyObject *
_wrap_picman_color_area_get_color(PyGObject *self)
{
    PicmanRGB rgb;

    picman_color_area_get_color(PICMAN_COLOR_AREA(self->obj), &rgb);

    return pypicman_rgb_new(&rgb);
}
%%
override picman_color_hex_entry_get_color noargs
static PyObject *
_wrap_picman_color_hex_entry_get_color(PyGObject *self)
{
    PicmanRGB rgb;

    picman_color_hex_entry_get_color(PICMAN_COLOR_HEX_ENTRY(self->obj), &rgb);

    return pypicman_rgb_new(&rgb);
}
%%
override picman_color_notebook_get_color noargs
static PyObject *
_wrap_picman_color_notebook_get_color(PyGObject *self)
{
    PicmanRGB rgb;

    picman_color_notebook_get_color(PICMAN_COLOR_NOTEBOOK(self->obj), &rgb);

    return pypicman_rgb_new(&rgb);
}
%%
override picman_color_selection_get_color noargs
static PyObject *
_wrap_picman_color_selection_get_color(PyGObject *self)
{
    PicmanRGB rgb;

    picman_color_selection_get_color(PICMAN_COLOR_SELECTION(self->obj), &rgb);

    return pypicman_rgb_new(&rgb);
}
%%
override picman_color_selection_get_old_color noargs
static PyObject *
_wrap_picman_color_selection_get_old_color(PyGObject *self)
{
    PicmanRGB rgb;

    picman_color_selection_get_old_color(PICMAN_COLOR_SELECTION(self->obj), &rgb);

    return pypicman_rgb_new(&rgb);
}
%%
override picman_enum_store_new kwargs
static int
_wrap_picman_enum_store_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "enum_type", "minimum", "maximum", NULL };
    PyObject *py_enum_type = NULL;
    PyObject *py_minimum = NULL;
    PyObject *py_maximum = NULL;
    GType enum_type;
    GEnumClass *enum_class;
    gint minimum, maximum;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O|O!O!:PicmanEnumStore.__init__", kwlist,
                                      &py_enum_type, &PyInt_Type, &py_minimum,
                                      &PyInt_Type, &py_maximum))
        return -1;
    if ((enum_type = pyg_type_from_object(py_enum_type)) == 0)
        return -1;

    enum_class = g_type_class_ref(enum_type);

    if (py_minimum == NULL)
        minimum = enum_class->minimum;
    else
        minimum = PyInt_AsLong(py_minimum);
    
    if (py_maximum == NULL)
        maximum = enum_class->maximum;
    else
        maximum = PyInt_AsLong(py_maximum);
    
    g_type_class_unref(enum_class);

    self->obj = (GObject *)picman_enum_store_new_with_range(enum_type, minimum, maximum);

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create PicmanEnumStore object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
%%
override picman_zoom_preview_new_with_model kwargs
static int
_wrap_picman_zoom_preview_new_with_model(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "drawable", "model", NULL };
    PyPicmanDrawable *py_drawable;
    PyGObject *py_zoom_model = NULL;
    PicmanZoomModel *zoom_model;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!|O!:PicmanZoomPreview.__init__", kwlist,
                                     PyPicmanDrawable_Type, &py_drawable,
                                     &PyPicmanZoomModel_Type, &py_zoom_model))
        return -1;

    if (py_zoom_model)
        zoom_model = (PicmanZoomModel*)py_zoom_model->obj;
    else
        zoom_model = NULL;

    if (!py_drawable->drawable)
        py_drawable->drawable = picman_drawable_get(py_drawable->ID);

    if (pygobject_construct(self, "drawable", py_drawable->drawable, "model", zoom_model, NULL))
        return -1;

    g_object_set_data_full(self->obj, "pypicman-zoom-preview-pydrawable",
                           py_drawable,
                           (GDestroyNotify)pypicman_decref_callback);

    Py_INCREF(py_drawable);

    return 0;
}
%%
new-constructor PICMAN_TYPE_ZOOM_PREVIEW
%%
override picman_aspect_preview_new kwargs
static int
_wrap_picman_aspect_preview_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "drawable", NULL };
    PyPicmanDrawable *py_drawable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!|:PicmanAspectPreview.__init__", kwlist,
                                     PyPicmanDrawable_Type, &py_drawable))
        return -1;

    if (!py_drawable->drawable)
        py_drawable->drawable = picman_drawable_get(py_drawable->ID);
    
    if (pygobject_construct(self, "drawable", py_drawable->drawable, NULL))
        return -1;
    
    g_signal_connect_swapped(self->obj, "destroy",
                             (GCallback)pypicman_decref_callback, py_drawable);
    Py_INCREF(py_drawable);

    return 0;
}
%%
new-constructor PICMAN_TYPE_ASPECT_PREVIEW
%%
override picman_drawable_preview_new kwargs
static int
_wrap_picman_drawable_preview_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = { "drawable", NULL };
    PyPicmanDrawable *py_drawable;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
                                     "O!|:PicmanDrawablePreview.__init__", kwlist,
                                     PyPicmanDrawable_Type, &py_drawable))
        return -1;

    if (!py_drawable->drawable)
        py_drawable->drawable = picman_drawable_get(py_drawable->ID);
  
    if (pygobject_construct(self, "drawable", py_drawable->drawable, NULL))
        return -1;

    g_object_set_data_full(self->obj, "pypicman-drawable-preview-pydrawable",
                           py_drawable, 
                           (GDestroyNotify)pypicman_decref_callback);

    Py_INCREF(py_drawable);

    return 0;
}

%%
new-constructor PICMAN_TYPE_DRAWABLE_PREVIEW
%%
override picman_ruler_get_range noargs
static PyObject *
_wrap_picman_ruler_get_range(PyGObject *self)
{
    gdouble lower, upper, max_size;

    picman_ruler_get_range(PICMAN_RULER(self->obj), &lower, &upper, &max_size);

    return Py_BuildValue("(ddd)", lower, upper, max_size);
}
